\section{Data model, annotation and query}\label{sec:dataquery}


In this section, we first illustrate the data model. Then, we
formalize the queries that scientists in this domain tend to ask. 

\subsection{Data model}\label{sec:datamodel}

%Data model: Data, attribute, data value set
When a scientist contributes data into an integrated data repository,
a widely accepted way is to convert each dataset to a data
table\cite{tdar} or treated as a separate object entity\cite{knb}. 
{\bf (HP: is it really widely used? any other system uses this
  way?. Add more citations here.)}
In using this method, the database contains metadata of each
dataset and the definition of the data table (e.g., attribute/column
name, attribute type, etc). 


%HP: 
%An alternative way to organize the data is to store them in one big
%data table with three columns data\_file, attribute\_name,
%attribute\_value. The problem with this structure is that the
%attribute\_value are different types.
In our work, we focus on querying this kind of data repository (or
databases). To formalize the scenario, we use $D$ to denote the set of data
tables in the data repository and $d$ to refer to a specific data
table. Each data table $d$ contains metadata about the attribute
definition $Attr_{d}$. Sometimes, we also use {\em column} to refer to an
attribute. 
Given one data table $d$, an attribute $attr_i \in Attr_{d}$ or column index $i$, 
$d[attr_i]$ or $d[i]$ represents the set of values for the attribute
$attr_i$ or for the $i$-th column.
%HP: Implementation detail (no need to put it in the paper): 
%When we put the data to data tables, we add a unique record id for
%each row in the data. This is used to get the unique record id. 

\subsection{Annotation}\label{sec:annotation}



%What kinds of annotation information is needed. 
We use $A$ to denote the annotation of one dataset. 
Internally, we keep the following information for the
annotation. 

For a data table $d$ with annotation $A$, the system keeps the
corresponding information between them in $AD$ tables. 
Besides it, we also have four main concepts to describe: 
observation type (OT), measurement type (MT), and
context type (CT), and the mapping (Map) from the measurement type to
resource attributes.  
So, the annotation contains the following information. 

\begin{itemize}
\item $AD$ = $\{(d_{id}, A_{id}, d_{meta})\}$ to keep the information
  of data sets $d_{id}$-s and their related annotations
  $A_{id}$. Here, $d_{meta}$ is an abstract attribute for all the
  other metadata of $d_{id}$. 
\item $OT$ = $\{(\underline{A_{id},ot_{id}}, et, isDistinct)\}$ to
  describe an observation type. It denotes on which
  entity type (object in the real world) the observation is made. 
Very often, more than one observation can be made on one entity. Thus,{\em
  isDistinct} is used to denote whether the same value of key
measurements of an obbservation types can uniquely identify one
observation or not. 
\item $MT$ = $\{(\underline{A_{id}, mt_{id}}, ot_{id},isKey,
  Cha, \cdots)\}$. Generally, $MT$ contains information about
  characteristic ($Cha$), Standard, Protocol and Precision. We do not include them
  here to make the description clearer. Here, {\em isKey} is used to denote
  whether one measurement type is the key measurement for the
  observation type $OT_{id}$ or not. 
\item $CT$ = $\{(\underline{A_{id}, ct_{id}}, ot_{id}, cot_{id}, Rel,
  isIdentify)\}$ where $cot$ represents the context observation
  type. 
\item $Map$ = $\{(\underline{A_{id},mt_{id}, attr_i, mapCond, mapVal},
  Val\}$. This structure denotes the correspondences between an
  measurement type ($mt_{id}$ and an attribute $attr_i$ in an dataset
  $d_{id}$ for a given condition $mapCond$. 
\end{itemize}

We use the following example to illustrate the concepts in the
annotation. 



\begin{example}
$OT$ = \{($A_1, OT_1$, tree, false),($A_1, OT_2$, GeoSpot, true) \}
  denotes that annotation $A_1$ are for two observation types. One
  type $OT_1$ is on real world entity ``tree'' and the values of its key measurements
  do not uniquely identify a distinct observation. The other type
  $OT_2$ is for real world entity ``GeoSpot'' (i.e., geospatial
  location) and its key measurement types can identify it's unique
  observations. \from{HP}{Introduce key measurements before this.}

$MT$ =\{($A_1, MT_1, OT_1$, Species, true), 
($A_1, MT_2, OT_1$, SpecNo, true), 
($A_1, MT_3, OT_1$, Height, false),
($A_1, MT_4, OT_2$, Plot\_State, true), 
($A_1, MT_5, OT_2$, Plot\_Area, false)\} represents that $OT_1$
(for ``tree'') has three measurement types ($MT_1, MT_2$, $MT_3$) for characteristics
``Species'', ``SpecNo'', and ``Height''. The fist two measurement
  types together form the key measurement type for $OT_1$. 
$OT_2$ (for ``GeoSpot'') has one key measurement type $MT_4$ for
  characteristic ``Plot\_State'' and another measurement type $MT_5$
  for characteristic ``Plot\_Area''. 

$CT$ = \{($A_1$,$OT_1$, $OT_2$, within, true)\}. It shows that
observation of a {\em tree} is within the context of a geo-spatial
location. And this context is used to identify the uniqueness of the
observation. E.g., a tree with species name ``piru'' and species no
$1$ in California
%$(34^{\circ}8'3N,118^{\circ}14'37W)$ (Los Angeles in California) 
is different from a tree with 
the same species name ``piru'' at Oregon. 
%location $36^{\circ}10'30N,115^{\circ}8'11W$ (Las Vegas in
%California). 

%HP coordinates material: 
%http://www.traveljournals.net/explore/united_states/map/u1662328/los_angeles.html
%http://en.wikipedia.org/wiki/Las_Vegas,_Nevada

$Map$ = \{($A_1$, $MT_1$, ``code'', ``eq `piru''', ``Picea rubens''),
%($A_1$, $MT_1$, ``code'', ``eq `abba''', ``Abies balsamea''),
%($A_1$, $MT_1$, ``code'', ``eq `capo''', ``California poppy''),
($A_1$, $MT_2$,``no'', null,), 
($A_1$, $MT_3$, ``plt'', null,), 
($A_1$, $MT_4$,``area'', null,\}. 
The first mapping rules maps ``code''
attribute to the measurement type $MT_1$ (for ``Species''
characteristic) and change the value to ``Picea rubens'' if the code
is ``piru''. The meaning of the other mapping rules are very
obvious here, so we skip the details. 
\end{example}


\subsection{Observation and measurement (OM) query}
Above we defined the data model and the annotation. In this
sub-section, we formalize the queries that scientists are interested
in. We denote the queries on the observational data as {\em Observation
and measurement (OM) query}. 

As discussed in Section \ref{sec:intro}, it is generally impossible for a
scientist to formulate an OM query using the internal data structure
of a dataset because such data structures differ from contributors to
contributors. More realistically, they can pose queries
(Example \ref{eg:query}) related to key OM concepts, e.g., {\em
  observation, measurement,characteristic, and standard}, and these
OM concepts satisfy given keyword and context conditions. 

\begin{definition}[Basic OM query]\label{def:basic_omq}
A basic observation and measurement query is defined as 
\[Q::={\tt OMconcept:}\langle{\tt cond}\rangle\}\]
Here, 
\begin{itemize}
\item {\tt OMconcept} refers to one of the major OM terminologies. 
\item 
$\langle${\tt cond}$\rangle$ is in the form of 
{\tt f([distinct entity.]measurement) op value} 
where {\tt op} is a basic operator from $\{=, \neq, >, <\}$ 
and {\tt f} is an
aggregation function from $\{sum, avg, count, min, max\}$. 
{\tt distinct} and {\tt entity} are optional. 
\end{itemize}
\from{HP}{The symbol fonts are a little bit messy...need to
  distinguish between the keywords and variables.}
\end{definition}

\begin{definition}[Result of OM query]\label{def:qresult}
The result of a query $Q$ is a set of data objects (e.g., data tables) 
\{$d|d\in D \wedge d~satisfies~\langle ${\tt cond} $\rangle$\}. 
For each of such result $d$, we use $d~s.t.~Q$ to denote that
an data object $d$ satisfies the query. 
\end{definition}

Based on the different $\langle${\tt cond}$\rangle$ definitions,
``$d~satisfies~\langle${\tt cond}$\rangle$''
is translated differently. 
E.g., if $\langle${\tt cond}$\rangle$ is defined that the value of ``{\em area}'' need to be
smaller than $3.0$, then, ``$d~satisfies~{\tt cond}$'' is translated to
``$dv<3.0|dv\in d[area]$''.
 
Definition \ref{def:basic_omq} can formulate queries on
one specific observation and measurement. 
In real application, we need to consider the context relationship. 
\from{HP}{E.g., etc.}
So, we generalize the basic OM query to contextualized OM query as
follows. 

\begin{definition}[Contextualized OM query]\label{def:context_omq} A
  contextualized OM query is defined as:
\[CQ ::=Q_i \wedge {\tt context}(Q_i.{\tt OMconcept}, Q_j.{\tt
  OMconcept})\wedge Q_j\]
Here, $Q_i, Q_j$ are basic queries.
\end{definition}

For example, the queries in Example \ref{eg:query} can be formalized
as the following formal OM queries. 

%\begin{example}
\begin{itemize}
\item $Q_1$ = $Observation: \langle Species='Picea~rubens'\rangle$
\item $Q_2$ = $Observation_1: \langle Species='Picea~rubens'\rangle$\\
  $\wedge IN(Observation_1, Observation_2$) \\
$\wedge Observation_2: \langle Meas_{unknown}=`California'\rangle$
\item $Q_3$ = $Observation: \langle Species='Picea~rubens'$\\
$\wedge count(distinct~Species)\geq 5\rangle$
\item $Q_4$ = $Observation_1: \langle avg(distinct~tree.height)\geq 20.0 \rangle$ 
$\wedge IN(Observation_1, Observation_2)$\\
$\wedge Observation_2: \langle State='California'\rangle$\\
%Give me the data sets that have trees with average ``height''
%  than 20.0 in ``California''
\end{itemize}

%\end{example}


%\from{HP}{Add experiement: show the error rate (e.g., precision, recall, (or
%  directly $F_1$) of this method.? not needed?}