\documentclass[conference]{IEEEtran}

\ifCLASSINFOpdf
  % \usepackage[pdftex]{graphicx}
  % declare the path(s) where your graphic files are
  % \graphicspath{{../pdf/}{../jpeg/}}
  % and their extensions so you won't have to specify these with
  % every instance of \includegraphics
  % \DeclareGraphicsExtensions{.pdf,.jpeg,.png}
\else
  % or other class option (dvipsone, dvipdf, if not using dvips). graphicx
  % will default to the driver specified in the system graphics.cfg if no
  % driver is specified.
  % \usepackage[dvips]{graphicx}
  % declare the path(s) where your graphic files are
  % \graphicspath{{../eps/}}
  % and their extensions so you won't have to specify these with
  % every instance of \includegraphics
  % \DeclareGraphicsExtensions{.eps}
\fi

\usepackage{algorithm}
\usepackage{algorithmic}
 \renewcommand\floatpagefraction{0.99}
 \renewcommand\topfraction{0.99}
 \renewcommand\bottomfraction{0.99}
 \renewcommand\textfraction{.05}
 \setcounter{totalnumber}{5}

\newtheorem{example}{Example}[section]
\newtheorem{definition}{Definition}[section]
\newcommand{\from}[2]{{\bf[{\sc from #1:} #2]}}

\hyphenation{op-tical net-works semi-conduc-tor}

\begin{document}

\title{Querying Integrated Scientific Observation and Measurement Data}

% author names and affiliations
% use a multiple column layout for up to three different
% affiliations
\author{\IEEEauthorblockN{Michael Shell}
\IEEEauthorblockA{School of Electrical and\\Computer Engineering\\
Georgia Institute of Technology\\
Atlanta, Georgia 30332--0250\\
Email: http://www.michaelshell.org/contact.html}
\and
\IEEEauthorblockN{Homer Simpson}
\IEEEauthorblockA{Twentieth Century Fox\\
Springfield, USA\\
Email: homer@thesimpsons.com}
\and
\IEEEauthorblockN{James Kirk\\ and Montgomery Scott}
\IEEEauthorblockA{Starfleet Academy\\
San Francisco, California 96678-2391\\
Telephone: (800) 555--1212\\
Fax: (888) 555--1212}}

\maketitle


\begin{abstract}
%\boldmath
The abstract goes here.
\end{abstract}

% no keywords

\section{Introduction}
In this work, we study the query processing over integrated ecological
data through OBOE model\cite{DBLP:conf/er/BowersMS08}, a conceptual model used to interpret
observation and measurement data. 

\subsection{Background}
Introduce OBOE, annotation
Give an example of them.

\subsection{Contribution and paper organization}
Contributions of this work:
\begin{itemize}
\item Formalize the queries over observation and measurement query.
\item Propose three methods to evaluate queries. 
\end{itemize}

This paper is organized as follows. 
Section \ref{sec:relatedwork} reviews works that are related to this
research. Section \ref{sec:dataquery} formalize the data model and the
queries that people are interested to ask. 

\section{Related work}\label{sec:relatedwork}



\section{Data model, annotation and query}\label{sec:dataquery}

In many scientific domains (e.g., ecology, hydrology, earth science, geology), people collect observation and
measurement data. Such data record the observed value of some real
world entity at some specific place. E.g., ecologist studying the
growth pattern and treatments often need to record the tree height,
The collected data reflect the fact the tree height of a specific tree is 1.0in on
May 1, 2009 and 1.5in on May 1, 2010. ({\bf check whether this is
  realistic or not.})

In scientific domains where people collect observation and measurement data, there are
several commonly used and widely recognized canonical
concepts(\cite{oboe, om}). 
In this paper, we refer these concepts as OM concetps. 
The canonical concepts include {\em observation}, {\em measurement},
{\em characteristic}, {\em standard}, {\em protoca} or ({\em procedure}). 
For example, {\bf add an example to illustrate these concepts. }

When a user poses a query, it is unrealistic for a him/her to know the 
underlying data structure of the data.  
But they all know the well recognized OM conceps as discussed above. 
So, naturally, when searching such scientific data, people are more interested in finding datasets
related to such concepts, e.g., specific observation and measurement. 

In this section, we first illustrate the data model. Then, we
formalize the queries that scientists in this domain tend to ask. 

\subsection{Data model}\label{sec:datamodel}

When a scientist contributes dataset into the data repository, generally
each dataset is converted to a data table\cite{tdar} or treated as a separate
object entity\cite{knb}. 
So, the database contains metadata about each dataset, the data table
definition (e.g., attribute/column name, attribute type, etc). 
%\from{HP}{Another way to organize the data is to store them in one big
%data table with three columns data\_file, attribute\_name,
%attribute\_value. The problem with this organization is that the
%attribute\_value are different types. } 
To formalize the scenario, we use $D$ to denote the set of data
tables. Each data table contains metadata about the attribute
definition.  Sometimes, we also use {\em column} to denote the attribute. 
Let $d$ be one data table, 
$d[attr]$ or $d[idx]$ represents the set of values for the attribute
$attr$ or for the $idx$-th attribute. 
Besides the dataset, in the data store, we also keep the annotation
information. 
%Implementation detail (no need to put it in the paper): 
%When we put the data to data tables, we add a unique record id for
%each row in the data. This is used to get the unique record id. 

\subsection{Annotation}\label{sec:annotation}.
In the Ecology domain, people are using annotations to connect
datasets to the OBOE model. 
{\bf TODO: Put a screen-dump of annotation.}
When some annotations are done over data tables, the system keeps the
information $\langle AnnotId, DTableId\rangle$.

Map annotation information 
We use $A$ to denote the annotation of one dataset. 
More specifically,
To describe an observation, we need to denote on which entity (object in the
real world) the observation is made.
Very often, more than one observation can be made on one entity.   
\begin{itemize}
\item A.ObsType = $\{\langle \underline{AnnotId,ObsTypeId}, EntTypeId,
  isDistinct \rangle\}$ 
\item A.MeasType = $\{\langle \underline{AnnotId, MeasTypeId}, ObsTypeId,
  CharType, StdType, ProtType, Precision, isKey \rangle\}$ 
\item A.ContextType = $\{\langle \underline{AnnotId, ObsTypeId, ContextObsTypeId, RelType}, isIdentify\rangle\}$
\item A.Map = $\{\langle \underline{AnnotId,MeasTypeId, ResAttribute, Cond}, Val\rangle\}$
\end{itemize}

``AnnotId'' denotes the resource (e.g., data table) the annotation is on.

{\bf TODO: Describe the constraints in annotation}

\subsection{Observation and measurement (OM) query}

{\bf TODO: Have a running example from here.}
Observation and measurement (OM) query

\begin{definition}[Basic OM query]\label{def:basic_omq}
A basic observation and measurement query is defined as $Q$::={\tt
  concept:cond}. 
Here, {\tt concept} is the main term in an observation model. 
In using the OBOE model, it can be observation, measurement,
characteristic or standard. 
{\tt cond} is in the form of $f([distinct]~attr)~op~value$ where $op$ is
basic operator from $\{=, \neq, >, <\}$ and $f$ is an
aggregation function from $\{sum, avg, count, min, max\}$. 
\end{definition}

\begin{definition}\label{def:qresult}
The result of a query $Q$ is a set of data objects (e.g., data tables) 
$\{d|d\in D \wedge d~satisfies~{\tt cond}\}$. 
%$\{d|d\in D \wedge (value~op~dv = true, dv\in d[attr])\}$. 
For each of such result $d$, we use $d~s.t.~Q$ to denote that
data object $d$ satisfies the query. 
\end{definition}
 
Definition \ref{def:basic_omq} can formulate queries on the
one specific observation and measurement. 
However, it fails to catch the observation context relationship. 
E.g., {\bf TODO: }
So, we generalize the basic OM query to contextualized OM query as
follows. 

\begin{definition}[Contextualized OM query]\label{def:context_omq}
$CQ$::=$Q_1~${\tt context}($Q_1.concept, Q_2.concept$)$~Q_2$. Here $Q_i$ is a basic query
in the form of {\tt concept:cond}. 
\end{definition}

Given the dataset in Figure \ref{}. 
People may ask the following queries. 

\begin{itemize}
\item $Q_1$: Give me the datasets that contain species ``Picea rubens'' observations.
%$Q_2$: Give me the datasets that have measurements on ``area''  characteristics. 
\item $Q_2$: Give me the datasets that contain species ``Picea rubens''
  observations in ``California''. 
\item $Q_3$: Give me the dataset that contains at least five distinct ``Picea rubens'' observations.
\item $Q_4$: Give me the datasets that have trees with average ``height''
  than 20in in year 2009. 
% Shawn: an example on summarize one measure with respect to another.
% This could take two forms: one where the context forms the groups
% (like by year), and another where the two measurements are within the
% same context (like finding correlations).
\end{itemize}

They can be formalized as the following queries. 

\begin{example}
The given example queries can be represented in the formal query
format. 
\begin{itemize}
\item $Observation: \langle Species='Picea~rubens'\rangle$
\item $Observation_1: \langle Species='Picea~rubens'\rangle$\\
  $IN(Observation_1, Observation_2$) \\
$Observation_2: \langle Meas_{unknown}=`California'\rangle$
\item $Observation: \langle Species='Picea~rubens' $\\
$\wedge
  count(distinct~Species)\geq 5\rangle$
\item $??$
\end{itemize}

\end{example}

\section{Naive method}\label{sec:naive}
A very direct way to help searching would be to index the data with
the data with all the values, then search over these values. 
This may get wrong results. 

{\bf TODO: An example to show that the naive method give wrong answers.}
{\bf Experiement: show the error rate (e.g., precision, recall, (or
  directly $F_1$) of this method.}

\section{Querying annotated and integrated OM data}

As we analyzed in Section \ref{sec:relatedwork}, there are two extrems
in querying integrated data. 
One is to rewrite the original query to a series of new queries over
the data; the other is to materialize the data to a consistent data
model and then answer the query over the materialized database. 
In Section \ref{sec:matdb} and \ref{sec:queryrewrite}, we introduce
our strategies in answering the queries. 

%\subsection{Framework and operators}

\subsection{Query rewriting}\label{sec:queryrewrite}

As described in Section \ref{sec:dataquery}, 
a user's query generally does not contain the underlying data
structure because the user cannot get such information. 
On the contrary, they formulate their query with the well recognized
OM concept terminologies such as observation
measurement, characteristic, etc. 
To answer such query from the original data model (i.e., dataset
metadata and data tables), we need to {\em rewrite} the quey over the
real data table. 
In what follows, we first sketch the re-writing process. Then, we
detailed the procedure in using the data model and
structures. Finally, we include the process for the more complicated
cases (e.g., with distinct, aggregate). 

Roughly speaking, the query rewriting consists of two steps:
\begin{itemize}
\item From the given query, find the relevant data tables and
  attributes that need to be used answer the given query. 
\item Translate the given query to queries over the relevant data
  tables. 
\end{itemize}

{\bf TODO: put a figure here to illustrate the steps}. 

The first step is to map the OM query to the real data structure. 
We can utilize the annotation structure $A.Map$ which keeps the correspondences between
measurement type and table attributes. 
So, when the given concept is {\em measurement}, we can directly get
its related attribute names and annotation id $AnnotId$. 
In case that the given OM concept is a non-measurement concept, we can use
other Annotation structures $A.*$ to figure out the measurementt types. 
E.g., if the OM concept is Characteristic ``Species'', we can use
$A.MeasType$ to get the measurement type id. 

As mentioned in Section \ref{sec:annotation}, when some annotations are done over data tables, the system keeps the
information $\langle AnnotId, DTableId\rangle$. 
With the $AnnotId$, we can ge the data table information from the
metadata  $\langle AnnotId, DTableId\rangle$. 
Then, we get the relevant data table information and the needed attribute
information.

Let $RD$ be the set of relevant data tables and $d_{a_1} \cdots d_{a_m}$
are the related attributes for table $d\in RD$. We can translate the original OM query to SQL queries
over the data tables.  

[
{\tt 
SELECT DISTINCT d.record\_id\\
FROM d\\
WHERE $f(d_{a_1} \cdots d_{a_m}) = true$\\
$[$GROUP BY$]$\\
$[$HAVING$]$
}
]

The above describes the process for the most basic OM query. 
However, in the real application, people ask queries with distinct
observation or entity constraints. Also, people ask queries about
different observatitons using context. 

%Discuss how to deal with the distinct constraints.
Many times, a user may want to find {\em distinct} observations or
entities. In this case, the above simple solution cannot work
correctly because it treats observations in different rows as the same
observation. So, we need to use the annotation to figure out what
distinguishes one observation from another. 
When an observation type is denoted with {\em distinct yes} and some
of its measurement types are denoted with {\em key yes}, 
the values of the measurements on the key measurement types can
uniquely distinguish one observation from the other. 
To implement this, in SQL, we can perform ``group by'' operations on
the key measurement types of the observations. 

%Discuss how to deal with context
The above description discusses cases without context. 
However, in real application, the observation has context. 
When the context is not {\em identifying}, i.e., the context value
does not affect the uniqueness of one observation, this can be
processed as the basic way. 
When the context is denoted with {\em identifying yes}, it means the
identity of one observation also depend on the contextual
observation. 
In this case, we need to figure out the all the key measurement types
of one observation, then the ``GROUP BY'' operation should be on all
these key measurement types. 

{\bf TODO: put an example here.}

In this case, there is no need to change the SQL scripts.
the only change are the relevant attribute set $d_{a_1} \cdots
d_{a_m}$, which corresponds to not only the measurement types that
directly related to the observation, but also the measurement types
that are in the identifying context chain of the observation. 

\begin{example}\label{eg:query_reqerite_q1}
{\bf TODO: refine this example} 
Take $Q_1$ as example. The {\tt concept} is ``observation'' and {\tt cond} is {\em species = ``Picea rubens''}; 

From the annotation $A.MeasType$, we can find the measurement type
$m_3$ with the characteristic {\em species}. 
From the mapping $A.Map$, we further find that the attribute {\em spp} that the
measurement type $m_3$ is mapped to. 

The second step is to find the data file which really have this value. 
For this one, we find the data table, and do a selection on the table
content. 

{\bf TODO: SQL here.} 
\end{example}

From the above description, we can tell that the computation cost is to search the different data
tables. This way, for each candidate data table, we need to send an
SQL query to the server for evaluation purpose.
If the number of candidate data tables are small. This method should
work well. However, when we have a lot of candidate data tables, the
efficiency may be affected. 
In what follows, we introduce another strategy, which logically merge
the data content in different tables and perform queries ober the
materialized database. 

\subsection{Querying over materialized database}\label{sec:matdb}

The previous section shows the method to rewrite a given query. 
However, as we analyzed, the computation cost may be higher when the
candidate data tables are many. In this section, we propose another
strategy to make use of the existing optimization strategies of
current DBMS. 

The basic idea is to materialize the data into some centralized
concept tables with instances of entities, observations, measurements
and the contexts between observations. 
We call such concept tables core OBOE tables, and denote them as
$OBOE.*$. 
In partibular, we have the following concept instance tables. 
\begin{itemize}
\item $OBOE.EntityIns=\{\langle \underline{EntId}, EntType\rangle\}$ for all the entity instances;
\item $OBOE.ObsIns=\{\langle \underline{ObsId}, ObsType, EntId \rangle\}$ keeps all the observation instances;
\item $OBOE.MeasIns=\{\langle \underline{MeasId}, ObsId, MeasType, Val\rangle\}$ for all the measurement instances;
\item $OBOE.ContextIns =\{\langle \underline{ObsId, ConextObsId, ContextType}\rangle\}$ for all the context instances;
\end{itemize}

In what follows, we describe how to materialize the data into such
concept instance tables in Section \ref{sec:materialilzedb} when
considering all the distinct and context constratins. 
Then, in Section \ref{sec:materialilzedb}, we describe our strategy to
perform queries over materialized database. 

\subsubsection{Materialize data}\label{sec:materialilzedb}
{\bf: TODO: refine the writing in MaterializeDB and move them here.}

\subsubsection{Querying materialized database}\label{sec:materialilzedb}

\begin{example} \label{eg:materialize_db_q1}
Example \ref{eg:query_reqerite_q1} shows how to deal with $Q_1$ using
the query rewriting method. 
Using the  materialized database, the first step is the same.
After we know the data file, then we search the table {\em measurement\_instance} with the {\em mvalue=``Picea rubens''}. 
\end{example}

\begin{example}
We use $SQ_1$ as an example. 

The first step is to find the datasets that contain the metadata. 
The second step is to perform a query over the materialized database. 
%select mlabel, mvalue, count(*) as cnt from measurement_instance
%group by mvalue,mlabel having count(*)>=2;

Using the query rewriting, 
First, we find the data tables that contain the needed concepts. 
In each table, we need to figure out the distinct observations. 
From $m_i$ $obstype_i$, all the other measurements that are of
$obstype_i$. 
Group by the key measurements of $obstype_i$ if distinct yes.
If this observation type does not have any context, then the key
measurements are all the measurements directly defined under this
observatioin type. Otherwise, i.e., this observation type has context,
then the key measurements are all the measurements in the context
chain. 
\end{example}

\begin{example}
KQ3: Give me the datasets that contain species ``Picea rubens''
  observations in ``California''. 

Species = ``Picea rubens'' and observation has context {\em in}
another observation which has measurement of value ``California''. 
\end{example}

Using materializedDB, we can answer the query this way
First, Species --> mlabel, observation type 

select mtype, olabel from measurement\_type  \\
where chracteristic = 'Species';  \\

For the olabel found, \\
select context\_olabel\\
from context\_relationship\\
where olabel = 'olabel'; 

context\_olabel\_set is a set containing all the observation type
labels in the context chain. 

SELECT record\_id\\
FROM observation\_instance oi, observation\_instance coi,
context\_instance ci,
measurement\_instance mi, measurement\_instance cmi \\
WHERE mi.oid=ci.oid AND ci.oid = oi.oid and  cmi.oid=coi.oid AND ci.context\_oid =
coi.oid and oi.otype = 'olabel' and coi.otype $\in$
context\_olabel\_set
AND mi.mvalue=`Picea rubens' and cmi.mvalue='California';\\

Use query rewriting, what I can do? 
It's the same till to getting context\_olabel\_set. 

Get the asked condition columns and the context columns, 

select record\_id from data\_tables
where condition column 1='value1' and (context column1 = 'context
value' or context column2 = `context value', etc.);

\begin{example}
SQ2: Give me the datasets that have measurements with average ``area''
bigger than 5.0 square feet. 
\end{example}

Use materialized database: 
Analysis: ``Area'' is the context of some observation.
Area --> mlabel, observation type

From the context observation lable, find the observation labels, \\
select olabel\\
from context\_relationship\\
where context\_olabel = 'olabel'; 

Let olabel\_set  be the set containing all the observation type
labels that use ``Area'' as context. 

SELECT oi.record\_id \\
FROM observation\_instance oi, measurement\_instance mi, 
observation\_instance coi, measurement\_instance cmi,context\_instance ci\\
WHERE (mi.oid=ci.oid AND ci.oid = oi.oid) and (cmi.oid=coi.oid AND ci.context\_oid =
coi.oid) AND coi.otype $\in$ olabel\_set 
AND cmi.mlabel=`Area'
GROUP BY cmi.oid
HAVING avg(cmi.mvalue)>5.0in;


\section{Experiments}

Synthetic data generator. 

Algorithm to materialize DB. 
Report the time and space. 

Synthetic query generator. 

Test algorithm to perform query over materiazed DB.
Test algorithm to perform query-rewriting over materiazed DB.

Test algorithm for half-materialized data.

\section{Conclusion}


\bibliographystyle{IEEEtranS}
\bibliography{IEEEabrv,DataIntegration}

\end{document}

