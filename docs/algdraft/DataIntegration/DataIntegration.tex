\documentclass[conference]{IEEEtran}

\usepackage{algorithm}
\usepackage{algorithmic}
\renewcommand\floatpagefraction{0.99}
\renewcommand\topfraction{0.99}
\renewcommand\bottomfraction{0.99}
\renewcommand\textfraction{.05}
\setcounter{totalnumber}{5}

\newtheorem{example}{Example}[section]
\newtheorem{definition}{Definition}[section]
\newcommand{\from}[2]{{\bf[{\sc from #1:} #2]}}

\hyphenation{op-tical net-works semi-conduc-tor}

\begin{document}

\title{Querying Integrated Ecological Data}

% author names and affiliations
% use a multiple column layout for up to three different
% affiliations
\author{\IEEEauthorblockN{Michael Shell}
\IEEEauthorblockA{School of Electrical and\\Computer Engineering\\
Georgia Institute of Technology\\
Atlanta, Georgia 30332--0250\\
Email: http://www.michaelshell.org/contact.html}
\and
\IEEEauthorblockN{Homer Simpson}
\IEEEauthorblockA{Twentieth Century Fox\\
Springfield, USA\\
Email: homer@thesimpsons.com}
\and
\IEEEauthorblockN{James Kirk\\ and Montgomery Scott}
\IEEEauthorblockA{Starfleet Academy\\
San Francisco, California 96678-2391\\
Telephone: (800) 555--1212\\
Fax: (888) 555--1212}}

\maketitle


\begin{abstract}
%\boldmath
The abstract goes here.
\end{abstract}
% IEEEtran.cls defaults to using nonbold math in the Abstract.
% This preserves the distinction between vectors and scalars. However,
% if the conference you are submitting to favors bold math in the abstract,
% then you can use LaTeX's standard command \boldmath at the very start
% of the abstract to achieve this. Many IEEE journals/conferences frown on
% math in the abstract anyway.

% no keywords

\section{Introduction}
In this work, we study the query processing over integrated ecological
data through OBOE model\cite{DBLP:conf/er/BowersMS0}, a conceptual model used to interpret
observation and measurement data. 

Contributions of this work:
\begin{itemize}
\item Formalize the queries over observation and measurement query.
\item Propose three methods to evaluate queries. 
\end{itemize}

\section{Related work}

This is related

\section{Data model and query}

In the ecological domain, observation and measurement data are the
core. As a consequence, people are more interested in finding datasets
related to specific observation and measurements. 

\subsection{Data model}

We a scientist contributes dataset into the data repository, generally
each dataset is converted to a data table. 
So, the database contains metadata about each dataset, the data table
definition (e.g., attribute/column name, attribute type, etc). 

To formalize the senario, we use $D$ to denote the set of data tables. Let $d$ be one data table, 
$d[attr]$ or $d[idx]$ represents the set of values for the attribute
$attr$ or for the $idx$-th attribut. 

Generally, the dataset is connected to the OBOE model using
annotations. 

\from{HP}{Put the screendump of annotation.}

Map annotation information 
Through the annotation, 
We use $A$ to denote the annotation of one dataset. 




\from{HP}{Another way to organize the data is to store them in one big
data table with three columns data\_file, attribute\_name,
attribute\_value. The problem with this organizationo is that the
attribute\_value are different types. } 



%Implementation consideration: 
%When we put the data to data tables, we add a unique record id for
%each row in the data. This is used to get the unique record id. 


\subsection{Observation and measurement query}

Given dataset in Figure \ref{}. 


\begin{itemize}
\item $Q_1$: Give me the datasets that contain species ``Picea rubens'' observations.
%$Q_2$: Give me the datasets that have measurements on ``area''  characteristics. 
\item $Q_2$: Give me the datasets that contain species ``Picea rubens''
  observations in ``California''. 
\item $Q_3$: Give me the dataset that contains at least five distinct ``Picea rubens'' observations.
\item $Q_4$: Give me the datasets that have measurements with average ``area''
bigger than 5.0 square feet. 
\end{itemize}


We formalize the queries as follows. 

\begin{definition}
KQ1: $<concept>:<cond>$
Here, <concept> can be observation, measurement, characteristic, standard,
unit, etc.. 
<cond> is in the form of $func([distinct]~attr)~op~value$, here $op$ can be some
algorithmmic operators $=$, $\neq$, $>$, or $<$. 
$func$ are aggregation functions including sum, average, min and max. 

The result is a set of $d$, $\{d|d\in D \wedge (value~op~dv = true |dv\in d[attr])\}$.
\end{definition}

For each of such result, we denote that $d~s.t.~KQ$ meaning that
dataset $d$ satisfies the query. 
 
This is the baseline keyword style query. 
The following two queries are the basic queries. 

\begin{definition}
KQ2: $Q_1~context(Q_1.concept,Q_2)~Q_2 $, here $Q_i$ is a basic query
in the form of $<concept>:<cond>$. 
\end{definition}

\begin{example}
The given example queries can be represented in the formal query
format. 
\begin{itemize}
\item $Q_1 = Observation: Species='Picea rubens'$
\item $Q_2 = <Observation_1: Species='Picea rubens'>
  IN(Observation_1,Observation_2) <Observation_2:
  measurement_{unknown}=`California'>$
\item $Q_3 = Observation: Species='Picea rubens' \wedge
  count(distinct~Species)\geq 5$ \from{HP}{TODO}
\item $Q_4$ 
\end{itemize}

\end{example}


\section{Querying annotated and integrated ecological data}

All the datasets can be imported to a RDBMS for 

To answer such queries, a naive method is to 

\subsection{Materialized database}


{\bf HP:}{Copy the materials from materiazeDB to here. Skip now.}

\subsection{Query rewriting}


The information that users can have: metadata about the table. 

In the scientific data, it is unrealistic for the users to know the
table structure to perform the query. 

Use the materialized database, we would have four tables for all the datasets: 
entity, observation, measurement, context. 
and 4 tables for entity types, observation types, measurement types,
and context relationships.

To answer KQ1: it's simple join between 

\begin{example}
Take KQ1 as example. 
concept = observation, cond is {\em species = ``Picea rubens''}; 

The first step is to find the dataset that contain all the metadata. 
From the annotation, find the {\em measurement type} with {\em
  Characteristic} species. 
Here, it is $m_3$. From the mapping, we find that the attribute in the
table is {\em spp}. 

The second step is to find the data file which really have this
value. 
For this one, we find the data table, and do a select on the table
content. 

Use materialized database: 
The first step is the same, after we know the data file, then we
search the table {\em measurement\_instance} with the {\em mvalue=``Picea rubens''}. 

In this example, the computation cost is to search the different data
tables. To reduce this computation cost, we can materialize just the
measurement values. (How to do this? ) need more details. 

Half materialized: how to perform query over it. 
\end{example}

\begin{example}
We use $SQ_1$ as an example. 

The first step is to find the datasets that contain the metadata. 
The second step is to perform a query over the materialized database. 
%select mlabel, mvalue, count(*) as cnt from measurement_instance
%group by mvalue,mlabel having count(*)>=2;

Using the query rewriting, 
First, we find the data tables that contain the needed concepts. 
In each table, we need to figure out the distinct observations. 
From $m_i$ $obstype_i$, all the other measurements that are of
$obstype_i$. 
Group by the key measurements of $obstype_i$ if distinct yes.
If this observation type does not have any context, then the key
measurements are all the measurements directly defined under this
observatioin type. Otherwise, i.e., this observation type has context,
then the key measurements are all the measurements in the context
chain. 
\end{example}

\begin{example}
KQ3: Give me the datasets that contain species ``Picea rubens''
  observations in ``California''. 

Species = ``Picea rubens'' and observation has context {\em in}
another observation which has measurement of value ``California''. 
\end{example}

Using materializedDB, we can answer the query this way
First, Species --> mlabel, observation type 

select mtype, olabel from measurement\_type  \\
where chracteristic = 'Species';  \\

For the olabel found, \\
select context\_olabel\\
from context\_relationship\\
where olabel = 'olabel'; 

context\_olabel\_set is a set containing all the observation type
labels in the context chain. 

SELECT record\_id\\
FROM observation\_instance oi, observation\_instance coi,
context\_instance ci,
measurement\_instance mi, measurement\_instance cmi \\
WHERE mi.oid=ci.oid AND ci.oid = oi.oid and  cmi.oid=coi.oid AND ci.context\_oid =
coi.oid and oi.otype = 'olabel' and coi.otype $\in$
context\_olabel\_set
AND mi.mvalue=`Picea rubens' and cmi.mvalue='California';\\

Use query rewriting, what I can do? 
It's the same till to getting context\_olabel\_set. 

Get the asked condition columns and the context columns, 

select record\_id from data\_tables
where condition column 1='value1' and (context column1 = 'context
value' or context column2 = `context value', etc.);

\begin{example}
SQ2: Give me the datasets that have measurements with average ``area''
bigger than 5.0 square feet. 
\end{example}

Use materialized database: 
Analysis: ``Area'' is the context of some observation.
Area --> mlabel, observation type

From the context observation lable, find the observation labels, \\
select olabel\\
from context\_relationship\\
where context\_olabel = 'olabel'; 

Let olabel\_set  be the set containing all the observation type
labels that use ``Area'' as context. 

SELECT oi.record\_id \\
FROM observation\_instance oi, measurement\_instance mi, 
observation\_instance coi, measurement\_instance cmi,context\_instance ci\\
WHERE (mi.oid=ci.oid AND ci.oid = oi.oid) and (cmi.oid=coi.oid AND ci.context\_oid =
coi.oid) AND coi.otype $\in$ olabel\_set 
AND cmi.mlabel=`Area'
GROUP BY cmi.oid
HAVING avg(cmi.mvalue)>5.0in;


\section{Experiments}

Synthetic data generator. 

Algorithm to materialize DB. 
Report the time and space. 

Synthetic query generator. 

Test algorithm to perform query over materiazed DB.
Test algorithm to perform query-rewriting over materiazed DB.

Test algorithm for half-materialized data.

\section{Conclusion}


%\bibliographystyle{abbrv}
%\bibliography{model}
%\bibliographystyle{IEEEtran}
%\bibliography{IEEEabrv,DataIntegration}


%\begin{thebibliography}{1}
%\bibliographystyle{abbrv}
%\bibliography{model}
%\end{thebibliography}

\end{document}

