\documentclass[conference]{IEEEtran}

\ifCLASSINFOpdf
  % \usepackage[pdftex]{graphicx}
  % declare the path(s) where your graphic files are
  % \graphicspath{{../pdf/}{../jpeg/}}
  % and their extensions so you won't have to specify these with
  % every instance of \includegraphics
  % \DeclareGraphicsExtensions{.pdf,.jpeg,.png}
\else
  % or other class option (dvipsone, dvipdf, if not using dvips). graphicx
  % will default to the driver specified in the system graphics.cfg if no
  % driver is specified.
  % \usepackage[dvips]{graphicx}
  % declare the path(s) where your graphic files are
  % \graphicspath{{../eps/}}
  % and their extensions so you won't have to specify these with
  % every instance of \includegraphics
  % \DeclareGraphicsExtensions{.eps}
\fi

\usepackage{algorithm}
\usepackage{algorithmic}
 \renewcommand\floatpagefraction{0.99}
 \renewcommand\topfraction{0.99}
 \renewcommand\bottomfraction{0.99}
 \renewcommand\textfraction{.05}
 \setcounter{totalnumber}{5}

\newtheorem{example}{Example}[section]
\newtheorem{definition}{Definition}[section]
\newcommand{\from}[2]{{\bf[{\sc from #1:} #2]}}

\hyphenation{op-tical net-works semi-conduc-tor}

\begin{document}

\title{Querying Integrated Ecological Data}

% author names and affiliations
% use a multiple column layout for up to three different
% affiliations
\author{\IEEEauthorblockN{Michael Shell}
\IEEEauthorblockA{School of Electrical and\\Computer Engineering\\
Georgia Institute of Technology\\
Atlanta, Georgia 30332--0250\\
Email: http://www.michaelshell.org/contact.html}
\and
\IEEEauthorblockN{Homer Simpson}
\IEEEauthorblockA{Twentieth Century Fox\\
Springfield, USA\\
Email: homer@thesimpsons.com}
\and
\IEEEauthorblockN{James Kirk\\ and Montgomery Scott}
\IEEEauthorblockA{Starfleet Academy\\
San Francisco, California 96678-2391\\
Telephone: (800) 555--1212\\
Fax: (888) 555--1212}}

\maketitle


\begin{abstract}
%\boldmath
The abstract goes here.
\end{abstract}

% no keywords

\section{Introduction}
In this work, we study the query processing over integrated ecological
data through OBOE model\cite{DBLP:conf/er/BowersMS08}, a conceptual model used to interpret
observation and measurement data. 

\subsection{Background}
Introduce OBOE, annotation
Give an example of them.

\subsection{Contribution and paper organization}
Contributions of this work:
\begin{itemize}
\item Formalize the queries over observation and measurement query.
\item Propose three methods to evaluate queries. 
\end{itemize}

This paper is organized as follows. 
Section \ref{sec:relatedwork} reviews works that are related to this
research. Section \ref{sec:dataquery} formalize the data model and the
queries that people are interested to ask. 

\section{Related work}\label{sec:relatedwork}



\section{Data model, annotation and query}\label{sec:dataquery}

In the ecology domain, most data people collected are observation and
measurement data. {\bf Add one sentence to explain this.}
Naturally, when searching ecological data, people are more interested in finding datasets
related to specific observation and measurement. 
In this section, we first illustrate the data model. Then, we
formalize the queries that scientists in this domain tend to ask. 

\subsection{Data model}

When a scientist contributes dataset into the data repository, generally
each dataset is converted to a data table\cite{tdar} or treated as a separate
object entity\cite{knb}. 
So, the database contains metadata about each dataset, the data table
definition (e.g., attribute/column name, attribute type, etc). 
%\from{HP}{Another way to organize the data is to store them in one big
%data table with three columns data\_file, attribute\_name,
%attribute\_value. The problem with this organization is that the
%attribute\_value are different types. } 
To formalize the scenario, we use $D$ to denote the set of data
tables. Each data table contains metadata about the attribute
definition.  Sometimes, we also use {\em column} to denote the attribute. 
Let $d$ be one data table, 
$d[attr]$ or $d[idx]$ represents the set of values for the attribute
$attr$ or for the $idx$-th attribute. 
Besides the dataset, in the data store, we also keep the annotation
information. 
%Implementation detail (no need to put it in the paper): 
%When we put the data to data tables, we add a unique record id for
%each row in the data. This is used to get the unique record id. 

\subsection{Annotation}
In the Ecology domain, people are using annotations to connect
datasets to the OBOE model. 
{\bf TODO: Put a screen-dump of annotation.}

Map annotation information 
We use $A$ to denote the annotation of one dataset. 
More specifically,
To describe an observation, we need to denote on which entity (object in the
real world) the observation is made.
Very often, more than one observation can be made on one entity.   
\begin{itemize}
\item A.ObsType = $\{\langle \underline{AnnotId,ObsTypeId}, EntTypeId,
  isDistinct \rangle\}$ 
\item A.MeasType = $\{\langle \underline{AnnotId, MeasTypeId}, ObsTypeId,
  CharType, StdType, ProtType, Precision, isKey \rangle\}$ 
\item A.ContextType = $\{\langle \underline{AnnotId, ObsTypeId, ContextObsTypeId, RelType}, isIdentify\rangle\}$
\item A.Map = $\{\langle \underline{AnnotId,MeasTypeId, ResAttribute, Cond}, Val\rangle\}$
\end{itemize}

``AnnotId'' denotes the resource (e.g., data table) the annotation is on.

{\bf TODO:} Describe the constraints in annotation

\subsection{Observation and measurement query}

{\bf TODO: Have a running example from.}
Observation and measurement (OM) query

\begin{definition}[Basic OM query]\label{def:basic_omq}
A basic observation and measurement query is defined as $Q$::={\tt
  concept:cond}. 
Here, {\tt concept} is the main term in an observation model. 
In using the OBOE model, it can be observation, measurement,
characteristic or standard. 
{\tt cond} is in the form of $f([distinct]~attr)~op~value$ where $op$ is
basic operator from $\{=, \neq, >, <\}$ and $f$ is an
aggregation function from $\{sum, avg, count, min, max\}$. 
\end{definition}

\begin{definition}\label{def:qresult}
The result of a query $Q$ is a set of data objects (e.g., data tables) 
$\{d|d\in D \wedge d~satisfies~{\tt cond}\}$. 
%$\{d|d\in D \wedge (value~op~dv = true, dv\in d[attr])\}$. 
For each of such result $d$, we use $d~s.t.~Q$ to denote that
data object $d$ satisfies the query. 
\end{definition}
 
Definition \ref{def:basic_omq} can formulate queries on the
one specific observation and measurement. 
However, it fails to catch the observation context relationship. 
E.g., {\bf TODO: }
So, we generalize the basic OM query to contextualized OM query as
follows. 

\begin{definition}[Contextualized OM query]\label{def:context_omq}
$CQ$::=$Q_1~${\tt context}($Q_1.concept, Q_2.concept$)$~Q_2$. Here $Q_i$ is a basic query
in the form of {\tt concept:cond}. 
\end{definition}

Given the dataset in Figure \ref{}. 
People may ask the following queries. 

\begin{itemize}
\item $Q_1$: Give me the datasets that contain species ``Picea rubens'' observations.
%$Q_2$: Give me the datasets that have measurements on ``area''  characteristics. 
\item $Q_2$: Give me the datasets that contain species ``Picea rubens''
  observations in ``California''. 
\item $Q_3$: Give me the dataset that contains at least five distinct ``Picea rubens'' observations.
\item $Q_4$: Give me the datasets that have measurements with average ``area''
bigger than 5.0 square feet. 
\end{itemize}

They can be formalized as the following queries. 

\begin{example}
The given example queries can be represented in the formal query
format. 
\begin{itemize}
\item $Observation: \langle Species='Picea~rubens'\rangle$
\item $Observation_1: \langle Species='Picea~rubens'\rangle$\\
  $IN(Observation_1, Observation_2$) \\
$Observation_2: \langle Meas_{unknown}=`California'\rangle$
\item $Observation: \langle Species='Picea~rubens' $\\
$\wedge
  count(distinct~Species)\geq 5\rangle$
\item $??$
\end{itemize}

\end{example}

\section{Naive method}\label{sec:naive}
Index the data with all the values, then search over values. 
This may get wrong results. 

{\bf Experiement: show the error rate (e.g., precision, recall, $F_1$ of this method.}

\section{Querying annotated and integrated ecological data}

As we analyzed in Section \ref{sec:relatedwork}, there are two extrems
in querying integrated data. 
One is to rewrite the original query to a series of new queries over
the data; the other is to materialize the data to a consistent data
model and then answer the query over the materialized database. 
In Section \ref{sec:matdb} and \ref{sec:queryrewrite}, we introduce
our strategies in answering the queries. 

\subsection{Framework and operators}


\subsection{Querying over Materialized database}\label{sec:matdb}

\subsubsection{Materialize data}

\subsubsection{Querying materialized database}



\subsection{Query rewriting}\label{sec:queryrewrite}

For query rewriting, the first step is to find the candidate data
tables and the attribute name lists that can be used to answer our queries. 
To find the candidate data table, the metadata tables and annotation
tables are searched. 
When the candidate data tables and the needed attributes are known, 
the second step translate the needed queries over the candidate data
tables.   

When a query {\tt concept:cond} is given, the {\tt concept} can only be interpreted using
annotations. When seeing a basic concept (observation, measurement,
characteristic, protocal), their related concepts information can be
retrieved through $A.MeasType$, $A.ObsType$. 

From the {\em measuremen type} and $A.Map$, we can get the attribute
names; Then, using the attribute names and the metadata table (with
table and column definition), we can get the candidate data tables
with their corresponding attribute lists. 

If there is context, we need to use $A.ContextType$. 

If there is distinct constraint, need to find the key measurements. 
then, perform ``group by'' operation. 

From the annotation, find the {\em measurement type} with {\em
  Characteristic} species. 
Here, it is $m_3$. From the mapping, we find that the attribute in the
table is {\em spp}. 

The information that users can have: metadata about the table. 

In the scientific data, it is unrealistic for the users to know the
table structure to perform the query. 

Use the materialized database, we would have four tables for all the datasets: 
entity, observation, measurement, context. 
and 4 tables for entity types, observation types, measurement types,
and context relationships.

To answer KQ1: it's simple join between 

\begin{example}
Take KQ1 as example. 
concept = observation, cond is {\em species = ``Picea rubens''}; 



The second step is to find the data file which really have this
value. 
For this one, we find the data table, and do a select on the table
content. 

Use materialized database: 
The first step is the same, after we know the data file, then we
search the table {\em measurement\_instance} with the {\em mvalue=``Picea rubens''}. 

In this example, the computation cost is to search the different data
tables. To reduce this computation cost, we can materialize just the
measurement values. (How to do this? ) need more details. 

Half materialized: how to perform query over it. 
\end{example}

\begin{example}
We use $SQ_1$ as an example. 

The first step is to find the datasets that contain the metadata. 
The second step is to perform a query over the materialized database. 
%select mlabel, mvalue, count(*) as cnt from measurement_instance
%group by mvalue,mlabel having count(*)>=2;

Using the query rewriting, 
First, we find the data tables that contain the needed concepts. 
In each table, we need to figure out the distinct observations. 
From $m_i$ $obstype_i$, all the other measurements that are of
$obstype_i$. 
Group by the key measurements of $obstype_i$ if distinct yes.
If this observation type does not have any context, then the key
measurements are all the measurements directly defined under this
observatioin type. Otherwise, i.e., this observation type has context,
then the key measurements are all the measurements in the context
chain. 
\end{example}

\begin{example}
KQ3: Give me the datasets that contain species ``Picea rubens''
  observations in ``California''. 

Species = ``Picea rubens'' and observation has context {\em in}
another observation which has measurement of value ``California''. 
\end{example}

Using materializedDB, we can answer the query this way
First, Species --> mlabel, observation type 

select mtype, olabel from measurement\_type  \\
where chracteristic = 'Species';  \\

For the olabel found, \\
select context\_olabel\\
from context\_relationship\\
where olabel = 'olabel'; 

context\_olabel\_set is a set containing all the observation type
labels in the context chain. 

SELECT record\_id\\
FROM observation\_instance oi, observation\_instance coi,
context\_instance ci,
measurement\_instance mi, measurement\_instance cmi \\
WHERE mi.oid=ci.oid AND ci.oid = oi.oid and  cmi.oid=coi.oid AND ci.context\_oid =
coi.oid and oi.otype = 'olabel' and coi.otype $\in$
context\_olabel\_set
AND mi.mvalue=`Picea rubens' and cmi.mvalue='California';\\

Use query rewriting, what I can do? 
It's the same till to getting context\_olabel\_set. 

Get the asked condition columns and the context columns, 

select record\_id from data\_tables
where condition column 1='value1' and (context column1 = 'context
value' or context column2 = `context value', etc.);

\begin{example}
SQ2: Give me the datasets that have measurements with average ``area''
bigger than 5.0 square feet. 
\end{example}

Use materialized database: 
Analysis: ``Area'' is the context of some observation.
Area --> mlabel, observation type

From the context observation lable, find the observation labels, \\
select olabel\\
from context\_relationship\\
where context\_olabel = 'olabel'; 

Let olabel\_set  be the set containing all the observation type
labels that use ``Area'' as context. 

SELECT oi.record\_id \\
FROM observation\_instance oi, measurement\_instance mi, 
observation\_instance coi, measurement\_instance cmi,context\_instance ci\\
WHERE (mi.oid=ci.oid AND ci.oid = oi.oid) and (cmi.oid=coi.oid AND ci.context\_oid =
coi.oid) AND coi.otype $\in$ olabel\_set 
AND cmi.mlabel=`Area'
GROUP BY cmi.oid
HAVING avg(cmi.mvalue)>5.0in;


\section{Experiments}

Synthetic data generator. 

Algorithm to materialize DB. 
Report the time and space. 

Synthetic query generator. 

Test algorithm to perform query over materiazed DB.
Test algorithm to perform query-rewriting over materiazed DB.

Test algorithm for half-materialized data.

\section{Conclusion}


\bibliographystyle{IEEEtranS}
\bibliography{IEEEabrv,DataIntegration}

\end{document}

