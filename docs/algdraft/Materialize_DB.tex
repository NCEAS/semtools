\documentclass[10pt]{article}
%\title{}
%\author{}
%\date{}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{a4}
\usepackage{color}
\renewcommand\floatpagefraction{0.99}
\renewcommand\topfraction{0.99}
\renewcommand\bottomfraction{0.99}
\renewcommand\textfraction{.05}
\setcounter{totalnumber}{5}
%\setlength{\parindent}{0pt}
%\pdfpagewidth 8.5in
%\pdfpageheight 11in
\newtheorem{example}{Example}[section]
\begin{document}

Note that in our description, we use
$A.*$ to represent the annotation information.
More specifically,
\begin{itemize}
\item MeasType = $\{\langle \underline{MeasTypeId}, ObsTypeId, CharType, StdType, ProtType, Precision, Value, isKey \rangle\}$;
\item ObservationType = $\{\langle \underline{ObsTypeId}, EntTypeId, isUnique \rangle\}$ \\
	{\bf HP Question}: I did not use ``AnnotId'' in the algorithm, so I remove it here. How shall this be used?
\item ContextType = $\{\langle \underline{ObsTypeId, ContextObsTypeId, RelType}, isIdentify\rangle\}$\\
	{\bf HP Question}: Add the {\em isIdentify} for the purpose of checking whether we need to use one observation's context for key, is this ok?
\item Map = $\{\langle \underline{MeasTypeId, ObsTypeId, Cond}, Val\rangle\}$
\end{itemize}

$OBOE.*$, on the other hand, represent the {\em OUTPUT} data represented in the OBOE model. In detail,
\begin{itemize}
\item $Observation=\{\langle \underline{ObsId}, EntId \rangle\}$ keeps all the observation instances materialized from $Dataset$.\\
	{\bf HP Question}: I did not use ``AnnotId'' in the algorithm, so I remove it here. How shall this be used?
\item $Measurenebt=\{\langle \underline{MeasId}, ObsId, Characteristic, Val\rangle\}$\\     
	%{\bf HP Question}: I changed ``MeasType'' in the ppt to ``Characteristic'', is it right? It is consistent with the example.
         \textcolor{blue}{Changed to: }\\
	$Measurenebt=\{\langle \underline{MeasId}, \textcolor{blue}{MeasTypeId}, ObsId, Val\rangle\}$\\   
          {\bf HP note}: the other information about the measurement type, e.g., standard, characteristic, can be gotten using {\em MeasTypeId}.
         In  real application, we can think of "duplicating the measurement type" information. Too detail. Ignore here. 
\item $Entity=\{\langle \underline{EntId}, EntType\rangle\}$
\item $Context =\{\langle \underline{ObsId, ConextObsId, RelType}\rangle\}$\\
	{\bf HP Question}: I did not use ``Relationship" table, do we really need to instantiate this information?
\end{itemize}

Each row in the input dataset represents the information related to one observation and its contexts.

The algorithm tries to catch the {\em key}, {\em unique} and {\em identifying} constraints in the annotation during the materialization process.

%\newpage
\begin{algorithm} [htb]
\caption{{\bf MaterializeDB} ($Dataset, A$)}
{\small
\begin{algorithmic}
%\STATE{{\bf MaterializeDB} ($Dataset, A$)}
\STATE /* {\em Dataset}: [Input] in the form of flat file */\\
\STATE /* {\em A }:  [Input] Annotations*/
\STATE
\STATE $ObsIdx =\emptyset$;  /* for keeping index $\langle ObsTypeId, \textcolor{blue}{KeyVal}\rangle \rightarrow ObsId$*/
\STATE $EntIdx = \emptyset$;  /* for keeping index $\langle MeasTypeId, \textcolor{blue}{KeyVal}\rangle \rightarrow EntId$*/
\FOR { (each $Row\langle A1, A2, \cdots, An\rangle \in Dataset$)}	
	%\STATE MapRow($Row, MapList, ObsIdx, EntIdx$);
    \STATE $MeasSet = \emptyset$; /* Keep the set of new measurement instances*/

    \STATE
    \STATE/* 1. Create new orphan measurement instances*/
	\FOR {(each $m = \langle MeasTypeId, \textcolor{blue}{ResAttribute}, Cond, Val\rangle \in A.Map$)}
		
		\IF{\textcolor{blue}{($m.ResAttribute != Row.Ai.Attrname$) OR} ($Row.Ai$ does not satisfy $m.Cond$)}
		\STATE cotinue;
		\ENDIF
		\STATE $ObsTypeId$ = GetObsTypeId ($A.MeasType, m.MeasTypeId$);
		\STATE
		\STATE $MeasId$ = GetNewMeasId($OBOE.Measurement$);
		%\STATE $Cha$ = GetCharacteristic4Meas($A.MeasType, m.MeasTypeId$);
		%\STATE Create a measurement instance $mi = \langle MeasId, null, Cha, m.val\rangle$;		
		\STATE \textcolor{blue}{{\bf if}($m.Val!=NULL$) $MeasVal$ = $m.Val$; }
		\STATE \textcolor{blue}{{\bf else} $MeasVal$ = $Row.Ai.Val$;}
		\STATE Create a measurement instance $mi = \langle MeasId, MeasTypeId, null, MeasVal\rangle$;
		\STATE Add $mi$ to $MeasSet$;
	\ENDFOR

    \STATE
    \STATE /* 2. Get observation types and measurement types with new instances*/
    \STATE $KeyIdx=\emptyset$ /* Keep index for $ObsTypeId \rightarrow \{mi\}$ */
    \FOR{(each $mi \in MeasSet$)}
    \STATE $ObsTypeId$ = GetObsTypeId ($A.MeasType, mi.MeasTypeId$);
	\STATE Update $KeyIdx$ by changing the item $ObsTypeId \rightarrow \{mi\}$;
    \ENDFOR

    \STATE
    \FOR{(each $ObsTypeId \in KeyIdx.keys$)}
        \STATE /*Get the key value for this observation. \\
                   Case 1: generally, it is the value for the ``key'' measurement. \\
                   Case 2: several measurement types are marked with ``key yes'', the key value is the combined value of these several measurement. \\
                   Case 3: this object type is marked with ``identifying yes, the key value '' is the combined value with its context observation's key measurement values. */
        \STATE $KeyVal$ = GetObsTypeKeys ($ObsTypeId, KeyIdx$);

        \STATE
        \STATE /* 3. Get an existing or create a new entity instance*/
        \STATE $HasKey$ = false;
        \IF{($ObsTypeId$ has key measurements)}
            \STATE $HasKey$ = true;
        \ENDIF
    	\STATE $EntId$ = {\bf MaterializeEntity}($ObsTypeId, HasKey, KeyVal, EntIdx, A, OBOE$)
    	
        \STATE
        \STATE/* 4. Get an existing or create a new observation instance*/
         \STATE $ContextIdx = \emptyset$;  /* keep index $ObsTypeId \rightarrow ObsId$ to materialize context*/
        \FOR{(each $ObsTypeId \in KeyIdx.keys)$}
        \STATE $IsObsUnique$ = checkIfObsUnique($A.ObservationType, ObsTypeId$);
        \STATE $ObsHasKey$ = $HasKey~\&\& IsObsUnique$ ;
        \STATE $ObsId$ = {\bf MaterializeObs}($ObsTypeId, ObsHasKey,KeyVal,EntId,ObsIdx, OBOE$);

        \STATE
        \STATE /*Maintain the measurement instances for this observation*/
        \STATE $miSet$ = GetMeasInst($KeyIdx, ObsTypeId$);
        \IF{($ObsId$ is a new one)}
            \STATE Set the $obsId$ to each $mi \in miSet$ so that $mi$-s are not orphans;
        \ELSE
            \STATE Discard all the $mi \in miSet$;
        \ENDIF
        \STATE Put all the $mi \in miSet$ to $OBOE.Measurement$;
        \STATE

    	\STATE $ContextIdx = ContextIdx \cup \{ObsTypeId \rightarrow ObsId\}$;
        \ENDFOR
    \ENDFOR
    \STATE
	\STATE /*5. Materialize context relationships among observation instances*/
	\STATE {\bf MaterializeContext}($ContextIdx, A, OBOE$)
\ENDFOR
\STATE Return OBOE;
\end{algorithmic}
}
\end{algorithm}

\begin{algorithm} [htb]
\caption{{\bf MaterializeEntity}($ObsTypeId, HasKey, KeyVal, EntIdx, A, OBOE)$}
\begin{algorithmic}
\STATE $EntType$ = GetObsEntityType ($A.ObservationType, ObsTypeId$)
\STATE $CrtNewEntInst$ = true;
\IF{ ($HasKey$==true) }
	\STATE $EntId$ = GetEntId($ObsTypeId, KeyVal, EntIdx$); %/*From the current entity key index get the id of the entity instance*/
	\IF{($EntId$ is not Null)}
		\STATE $CrtNewEntInst$ = false;
	\ENDIF
\ENDIF
\IF{($CrtNewEntInst==true$)}
	\STATE $EntId$ = CrtEntId($EntType$);
	\STATE Create an entity instance $ei = \langle EntId, EntType\rangle $;
	\STATE Put $ei$ to $OBOE.Entity$;
	\IF{$HasKey$==true)}
        \STATE /*Only when this is the key measurement, we need to maintain the index*/
        \STATE $EntIdx = EntIdx \cup \{\langle ObsTypeId, KeyVal \rangle \rightarrow EntId$\};
    \ENDIF
\ENDIF
\STATE return $EntId$;
\end{algorithmic}
\end{algorithm}


\begin{algorithm} [htb]
\caption{{\bf MaterializeObs}($ObsTypeId, HasKey,KeyVal,EntId, ObsIdx, OBOE$)}
\begin{algorithmic}
		\STATE $CrtNewObsInst$ = true;
		\IF{ ($HasKey$==true) }
			\STATE $ObsId$ = GetObsId($ObsTypeId, KeyVal, ObsIdx$); %/*From the current observation key index get the id of the observation instance*/
			\IF{($ObsId$ is not Null)}
				\STATE $CrtNewObsInst$ = false;
			\ENDIF
		\ENDIF
		\IF{($CrtNewObsInst==true)$}
    		\STATE Create an observation instance $oi = \langle ObsId,  EntId\rangle $
    		\STATE Put $oi$ to $OBOE.Observation$;
    		\IF{($HasKey$==true)}
                \STATE /*Only when it has key measurement and it is identified as unique, we need to maintain the index*/
                \STATE $ObsIdx = ObsIdx \cup \{\langle ObsTypeId, KeyVal \rangle \rightarrow ObsId$\};
            \ENDIF
		\ENDIF
		\STATE Return $ObsId$;
\end{algorithmic}
\end{algorithm}


\begin{algorithm} [htb]
\caption{{\bf MaterializeContext}($ContextIdx, A, OBOE$)}
\begin{algorithmic}
\FOR{ ($ObsTypeId \rightarrow ObsId \in ContextIdx$)}
\STATE $ContextObsTypeId, Rel$ = GetContextObsTypeRel($A.ContextType, ObsTypeId$);
\IF{($ContextObsTypeId$ is not Null)}
	\STATE $ContextObsId$ = GetContextObsId($ContextIdx, ContextObsTypeId$);
	\STATE Create a context $c=\langle ObsId, ContextObsId, Rel\rangle$;
	\STATE Put $c$ to $OBOE.Context$;
\ENDIF
\ENDFOR
\end{algorithmic}
\end{algorithm}

We can run the example in page 6 in the powerpoint file to explain the algorithm.

For Row(2007, 1, piru, 35.8)
    \begin{itemize}
    \item Create a measurement $mi_1=\langle meas1, null, Year, 2007\rangle$
    \item Create a measurement $mi_2=\langle meas2, null, DBH, 35.8\rangle$
    \item Create a measurement $mi_3=\langle meas3, null, TaxonomicTypeName, Picea~rubens\rangle$
    \item Create a measurement $mi_4=\langle meas4, null, EntityName, 1\rangle$
    \item Get $MeasSet = \{mi_1, mi_2, mi_3, mi_4\}$;
    \item Step 2: Get $KeyIdx = \{o_1\rightarrow \{mi_1\}, o_2 \rightarrow \{mi_2, mi_3, mi_4\}\}$
    \item Step 3-4: for each observation types $o_1$ and $o_2$
    \item for $o_1$
    \begin{itemize}
        \item Since $m_1$ is specified as key, get the $KeyVal=2007$;
        \item No entity with this key exists in $EntIdx$, create an entity $ei=\langle ent1, TemporalRange\rangle$; Now, $EntIdx=\{\langle o1, 2007\rightarrow ent1\rangle\}$.
        \item Since $o_1$ is specified as {\em distinct}, need to make sure we do not create redundant observations. No entry with this key exists in $ObsIdx$, so, create an observation
        $oi = \langle obs1, ent1\rangle$. Now, $ObsIdx=\{\langle o1, 2007 \rangle \rightarrow obs1\}$
    \end{itemize}
    \item When deal with $o_2$,
        \begin{itemize}
        \item $KeyVal=1$.
        \item Create an entity $ei=\langle ent2, Tree\rangle$; $EntIdx=\{\langle o1, 2007\rightarrow ent1\rangle, \langle o2, 1\rightarrow ent2\rangle\}$.
        \item Create an observation $\langle obs2, ent2 \rangle$. No need to update $ObsIdx$ because $o2$ is not identified as {\em unique}.
        \end{itemize}
    \item Connect $mi_1$ to $obs1$;
    \item Connect $mi_2$, $mi_3$ and $mi_4$ to $obs2$;
    \item Set the context relationship between $obs1$ and $obs2$;
    \end{itemize}

For Row (2008, 1, piru, 36.2)
    \begin{itemize}
    \item Create a measurement $mi_5=\langle meas5, null, Year, 2007\rangle$
    \item Create a measurement $mi_6=\langle meas6, null, Year, 35.8\rangle$
    \item Create a measurement $mi_7=\langle meas7, null, TaxonomicTypeName, Picea~rubens\rangle$
    \item Create a measurement $mi_8=\langle meas8, null, EntityName, 1\rangle$
    \item Get $MeasSet = \{mi_5, mi_6, mi_7, mi_8\}$;
    \item Step 2: Get $KeyIdx = \{o_1\rightarrow \{mi_5\}, o_2 \rightarrow \{mi_6, mi_7, mi_8\}\}$
    \item for type $o_1$
    \begin{itemize}
        \item  $KeyVal=2008$;
        \item Create an entity $\langle ent3, TemporalRange\rangle$; $EntIdx=\{\langle o1, 2007 \rangle \rightarrow ent1, \langle o2, 1 \rangle \rightarrow ent2, \langle o1, 2008 \rangle \rightarrow ent3\}$.
         \item Create an observation $\langle obs3, ent3 \rangle$, and $ObsIdx=\{\langle o1, 2007\rightarrow obs1\rangle, \langle o2, 1\rightarrow obs2\rangle, \langle o1, 2008\rightarrow obs3\rangle\}$
    \end{itemize}
    \item When deal with $o_2$,
        \begin{itemize}
         \item $KeyVal=1$.
        \item {\bf Some item $\langle o2, 1 \rangle \rightarrow ent2$ is already in $EntIdx$, so get the entity id $ent2$. No need to create an entity.}
        \item Since $o2$ is not specified with {\em unique yet}, we NEED to create an observation $\langle obs4, ent2 \rangle$. No need to update $ObsIdx$.
        \end{itemize}
    \end{itemize}
For ROW (2008, 2, abba, 33.2)
    \begin{itemize}
        \item For $o1$'s measurement $2008$, since $\langle o1, 2008 \rangle \rightarrow ent3$ already exists in $EntIdx$, {\bf No need to create a new ENTITY}.
        \item Since $o1$ is specified with {\em unique yes}, and since $\langle o1, 2008 \rangle \rightarrow obs3 $ already exists in $ObsIdx$, {\bf No need to create a new OBSERVATION} and no need to put the measurement for $2008$ into OBOE model.
    \end{itemize}


\begin{table}[htb]
\begin{center}
\begin{tabular}{|l|l|l|}
\hline
plt & spp & dbh\\\hline
A & piru & 35.8 \\\hline
A & piru & 36.2 \\\hline
B & piru &33.2 \\\hline
\end{tabular}
\end{center}
\vspace{-0.2in}
\caption{Dataset 2 for Example \ref{eg2}}
\end{table}

\begin{example} [Example with identifying]\label{eg2}
Use the data in the following table as an example. 

For the {\bf first row}, after we run the first step, we got the three measurement instances $MeasSet=mi_1, mi_2, mi_3$. 
After the second step, we get $KeyIdx = \{\langle o_1\rightarrow \{mi_1\} \rangle, \langle o_2 \rightarrow \{mi_2, mi_3\}\}$.

Now we need to create observation and entity instances. 
To create entity instance, we need to see whether there is/are key measurements for each observatioin type.  
Here,  $o_1$ and $o_2$ have key measurements $m1$ and $m_2$ respectively. 
The same value of the key measurement will denote the same entity. 
For $o_1$, we get it's key value be $A$. Since there is no such a statement, we create an entity $ei_1$ of type $Plot$.
Simiarly, for $o_2$, the key value is $(A, Picea~rubens)$ since it has context $o_1$ with {\em identifying yes}, we create an entity $ei_2$ of type $Tree$. \\
$EntIdx = \{\langle o_1, A\rangle \rightarrow ei_1, \langle o_2, (A, Picea~rubens) \rangle \rightarrow ei_2\}$. 

To create observation instance, we need to see whethe the observation type is specified with distinct yes. 
Here, $o_1$ is specified with {\em distinct yes} while $o_2$ is not. 
We only check whether we need to merge observation instances for $o_1$ or not. 
We create an observation instance $oi_1$ whose entity is $ei_1$. 
We also create an observation instance $oi_2$ whose entity is $ei_2$. 
$ObsIdx = \{\langle o_1, A\rangle \rightarrow oi_1\}$. 

The next step is to connect the measurement instances to observation instances,  $mi_1 \rightarrow oi_1$, $mi_2, mi_3 \rightarrow oi_2$.

The last step for this row is to connect the observations using context relationship. For this instance, we connect $oi_1$ to $oi_2$ with context {\em Within}. 

For the {\bf second row}, after the first step, we also get three measurement instances $MeasSet=mi_4, mi_5, mi_6$. 
After the second step, we get $KeyIdx = \{\langle o_1\rightarrow \{mi_4\} \rangle, \langle o_2 \rightarrow \{mi_5, mi_6\}\}$.

When we create entities, 
we need to check whether there is any entity corresponding to Key value $\langle o_1, A\rangle$ $\langle, o_2, (A, Picea~rubens)\rangle$ or not.
We observe that they have corresponding $ei_1$ and $ei_2$. So, we don't need to create entity instances for them. 

Now, we create observatins, 
Since $o_1$ is specified with {\em distinct yes}, we just need to see whether we need to create a new observation for it or get an existing one. 
The key is $\langle o_1,A\rangle$, which corresponds to $oi_1$. So, we do not need to create a new observation for it. 
For $o_2$, since no {\em distinct yes} is specified, we create an observation $oi_3$ for it. 

For the next step, when we try to connect the measurement instances to observation instances, we realize that we do not create a new observation for $o_1$,
so it's related measurement instance $mi_4$ can be discarded. While for $o_2$, $m_5, m_6\rightarrow oi_3$. 

When we process the {\bf third row}, one thing to note is for $o_1$, now we have key value $\langle o_1, B\rangle$, we create a new entity for it.
For $o_2$, we have key value $\langle o_2, (B,~Picea~rubens)\rangle$ and create a new entity for it. 


\end{example}


\end{document} 

