\documentclass[preprint,number]{elsarticle} 
% other options: preprint, review, 1p, 3p, 5p, 
% bib options: authoryear, number, longtitle,
% other options: times


\newcommand{\Owlifier}{\textsf{Owlifier}}
\newcommand{\owlifier}{\textsf{owlifier}}

\newcommand{\myblock}[1]{\vspace{12pt}\noindent\textbf{#1}}

\newcommand{\secref}[1]{Sect.~\ref{#1}}
\newcommand{\figref}[1]{Fig.~\ref{#1}}

\title{Owlifier: Creating OWL-DL Ontologies from Simple
  Spreadsheet-Based Knowledge Descriptions\tnoteref{t1}}
%\tnotetext[t1]{This work supported in part by NSF grants ...}

\author[smb]{Shawn Bowers\corref{cor1}}
\ead{sbowers@ucdavis.edu}

\author[jsm]{Joshua S. Madin}
\ead{jmadin@bio.mq.edu.au}

\author[mps]{Mark P. Schildhauer}
\ead[url]{schild@nceas.ucsb.edu}

\cortext[cor1]{Corresponding author}

\address[smb]{UC Davis Genome Center}

\address[jsm]{Dept. of Biological Sciences, Macquarie University, Australia}

\address[mps]{National Center for Ecological Analysis and Synthesis,
  UC Santa Barbara}



\begin{document}

\begin{abstract}
  Discovery and integration of data is important in many ecological
  studies, especially those that concern broad-scale ecological
  questions. Discovery and integration is often a difficult and
  time-consuming task for researchers, in part because informal,
  ambiguous, and sometimes inconsistent terms are used to describe
  data semantics.  Ontologies can help address this problem by
  providing a means to define ecological concepts to more consistently
  annotate, relate, and search for data sets.
  %
  However, unlike in molecular biology or biomedicine, few ontology
  development efforts exist within ecology. Ontology development often
  requires considerable expertise in ontology languages and
  development tools, which is often a barrier for ontology creation in
  ecology. In this paper we address this problem by providing an
  approach for ontology creation that allows ecologists to use common
  spreadsheet tools to describe different aspects of an ontology.  We
  present conventions for creating, relating, and constraining
  concepts through spreadsheets, and provide software tools for
  converting these ontologies into equivalent OWL-DL
  representations. We also consider inverse translations, i.e., to
  convert ontologies represented using OWL-DL into our spreadsheet
  format. Our approach allows large lists of terms to be easily
  related and organized into concept hierarchies, and generally
   provides a more intuitive and natural interface for ontology
  development by ecologists.
\end{abstract}

\maketitle

\section{Introduction}

Within the fields of molecular biology and biomedicine considerable
effort has gone into developing ontologies for improving data
discovery and integration
\cite{bard04:_ontol_in_biolog,ashburner00:_gene_ontol}. While similar
benefits can be obtained for ecological data, far fewer efforts exist
to develop richer and more consistent terminologies of ecology
concepts
\cite{madin08:_advan_ecolog_resear_with_ontol,parr20:_data_sharin_in_ecolog_and_evolut}.
The use of formal ontologies can significantly enhance metadata
descriptions of ecological data. Annotating data with ontology terms
can both help users interpret data as well as enable advanced
capabilities for data discovery and integration, e.g., by exploiting
subsumption and part-of hierarchies as well as more formal constraints
such as cardinality restrictions on properties and term equivalence.

Efforts to engage scientists in the development of ontologies
typically leverage the W3C Web Ontology Language (OWL)
\cite{smith04:_owl_web_ontol_languag_guide} as a standard XML syntax
for representing and sharing ontologies. A key advantage of OWL is
that it is supported by a wide range of generic tools, including
editors
\cite{knublauch04:_editin_descr_logic_ontol_with,kalyanpur05:_swoop},
reasoning systems
\cite{sirin07:_pellet,tsarkov06:_fact_descr_logic_reason}, query
languages
\cite{prudhommeaux08:_sparq_query_languag_for_rdf,motik05:_query_answer_for_owl_dl_with_rules},
and storage technologies
\cite{carroll04:_jena,broekstra02:_sesam}. Most of these tools,
however, are primarily targeted at experts in knowledge engineering
and software development familiar with the underlying description
logic semantics of OWL-DL \cite{grau08:_owl}. This is especially true
with ontology editors (such as Protege, SWOOP, etc.), which allow for
very detailed ontology specifications, but at the same time require a
considerable amount of understanding of the underlying ontology
formalisms and syntax. Thus, we see the lack of suitable ontology
editing tools for scientists as one of the major barriers for more
wide-scale adoption of ontologies in ecology.


This paper presents a novel approach for ontology creation that aims
at being more intuitive for ecologists and that can be used to rapidly
construct large ontologies for describing scientific data. Our
approach is to allow scientists to use common spreadsheet-based tools
to describe, in an intuitive way, different aspects of an ontology,
and then to take these descriptions and convert them into full-fledged
OWL ontologies using a software application called \owlifier. An
\owlifier\ spreadsheet consists of a set of \emph{blocks} that have a
predefined template structure for users to fill in. Each non-empty row
in an \owlifier\ table constitutes a block. Each block defines
different aspects of an ontology including ontology classes,
subclasses, synonyms, and properties.  We also provide blocks for
plain-text descriptions of classes and properties, and for referencing
one or more existing ontologies (e.g., to extend an existing ontology
or to define ontology articulations). Blocks can be sparse (inheriting
from previous blocks), which can further simplify the creation of
large ontologies.

While not as expressive as OWL-DL, our approach can produce ontology
structures essential for enhanced data discovery and integration,
while at the same time provide a more accessible user interface for
ecologists. Further, our approach can be used to rapidly construct
class hierarchies from long lists of keywords using familiar
spreadsheet software. For instance, an ecologist can easily list (or
import) a set of terms, and then incrementally organize these into a
class hierarchy, define properties and constraints, etc. We have used
the \owlifier\ approach with ecologists and evolutionary biologists
working with trait data, and found that it enabled them to quickly and
easily comprehend and construct ontologies.

The rest of this paper is organized as follows. In
\secref{sec:owlifier} we describe the basic syntax and semantics of
\owlifier. We define blocks that support a large subset of OWL-DL and
that also generally follow the ontology creation guidelines defined in
\cite{rector04:_owl_pizzas}. We also simplify certain aspects of
ontology creation using OWL-DL, e.g., by assuming classes are disjoint
by default (unless specified otherwise) and by applying implicit
property restriction closures \cite{rector04:_owl_pizzas}. In
\secref{sec:properties} we describe additional characteristics of
\owlifier\ and discuss issues with respect to classification and
reasoning. In \secref{sec:implementation} we briefly describe the
\owlifier\ implementation, and conlcude in \secref{sec:conclusion}
with related and future work. In general, the goal of \owlifier\ is
not to support all constructs in OWL-DL, but instead to provide a
higher-level ontology syntax (via spreadsheet blocks) that is easy for
ecologists to use and understand while also providing the necessary
constructs for developing typical ecological ontologies. By compiling
\owlifier\ to OWL-DL, we also allow for experts to refine and extend
the ontology using more advanced ontology editing tools if necessary.



\section{\Owlifier\ Syntax and Semantics}
\label{sec:owlifier}

An \owlifier\ table defines an OWL-DL
\cite{smith04:_owl_web_ontol_languag_guide} ontology through a set of
\emph{blocks} representing one or more ontology definitions.  Each
non-empty row in an \owlifier\ table corresponds to a block. The type
of the block is given in the first column of the row. We describe each
type of block supported by \owlifier\ below. Here we assume that if
any properties or classes used in a block are undefined, i.e., are not
imported from another ontology, then they are added to the ontology
being specified by the \owlifier\ table. In general, we name blocks
according to the more generic terms used in
\cite{bowers08:_concep_model_framew_for_expres,madina07:_ontol_for_descr_and_synth}
instead of those of OWL-DL. This allows \owlifier\ to generate
ontologies that extend the observational model of
\cite{bowers08:_concep_model_framew_for_expres,madina07:_ontol_for_descr_and_synth}
for data annotation, and in certain cases avoids confusion with
established terms used within biology.

\myblock{Import Blocks.} Import blocks assign namespace labels to
external ontologies. Each external ontology is imported into the
current ontology. We refer to the ontologies of import blocks as
\emph{imported ontologies}.  Using import blocks, classes and
properties of imported ontologies can be used within other blocks of
an \owlifier\ table.  Rows containing import blocks take the form
\begin{itemize}
\item[]
  \begin{tabular}{|l|l|l|}\hline
    \texttt{import} & $n$ & $u$ \\ \hline 
  \end{tabular} 
\end{itemize}
where $n$ is a namespace label and $u$ is an OWL ontology URI. Classes
and properties from imported ontologies are referenced by prefixing
the namespace label $n$ to the corresponding class or property name in
the normal way. As an example, the following block imports the ``earth
realm'' ontology from the set of SWEET ontologies
\cite{raskin:_seman_web_for_earth_and}
\begin{tabbing}
  ~~\texttt{import}  \texttt{sweet} 
  \texttt{http://sweet.jpl.nasa.gov/ontology/earthrealm.owl}
\end{tabbing}
With this import block the class denoting Marine Ecosystems (a class
defined in the above ontology) can be referred to from within an
\owlifier\ table using the expression
\texttt{sweet:MarineEcosystem}. Because this class refers to a class
in another ontology, we refer to it as an \emph{imported class}.


\myblock{Entity Blocks.} Entity blocks are the primary blocks used to
define ontologies. An entity block introduces new OWL classes and
specifies subclass relationships. Imported classes may also be used
within entity blocks by prefixing class names with namespace labels
(as described above).  We use the term `entity' to conform to the
observational model of \cite{bowers08:_concep_model_framew_for_expres}
and to avoid confusion with the term `class' used within biological
taxonomies. Rows containing entity blocks take the form
\begin{itemize}
\item[] 
  \begin{tabular}{|l|l|l|l|l|}\hline
    \texttt{entity} & $c_1$ & $c_2$ & \dots & $c_n$ \\ \hline 
  \end{tabular} \hfill ($n \ge 1$)
\end{itemize}
where each $c$ is a class, and each $c_i$ is asserted in the current
ontology to subsume $c_{i+1}$, for $1 \le i < n$. That is, each $c_i$
in a concept block induces the description-logic axiom $c_{i+1}
\sqsubseteq c_i$.  If both $c_i$ and $c_{i+1}$ are imported classes,
we say that the block defines an ``articulation'' (i.e., mapping)
between the two classes. The following concept block defines a simple
subclass hierarchy
\begin{tabbing}
  ~~\texttt{entity} \texttt{PhysicalFeature} 
    \texttt{AquaticPhysicalFeature} \texttt{River}
\end{tabbing}
stating that Physical Feature, Aquatic Physical Feature, and River are
classes, and that River is a subclass of Aquatic Physical Feature, and
Aquatic Physical Feature is a subclass of Physical Feature.


\myblock{Synonym Blocks.} Synonym blocks define equivalence
relationships between ontology classes.  Rows containing synonym
blocks take the form
\begin{itemize}
\item[] 
  \begin{tabular}{|l|l|l|l|l|}\hline
    \texttt{synonym} & $c_1$ & $c_2$ & \dots & $c_n$ \\ \hline 
  \end{tabular} \hfill ($n \ge 2$)
\end{itemize}
stating that each class $c_i$ is equivalent to class $c_{i+1}$ in the
current ontology, for $1 \le i < n$. Each $c_i$ in a synonym blocks
induces a description logic axiom of the form $c_i \equiv c_{i+1}$. As
an example, the block
\begin{tabbing}
  ~~\texttt{synonym} \texttt{Maize} \texttt{Corn}
\end{tabbing}
defines Maize and Corn as synonyms, i.e., as equivalent classes.


\myblock{Overlap Blocks.} Except in certain situations (see
\secref{sec:properties}), classes are assumed to be disjoint in
\owlifier.  Overlap blocks explicitly relax this assumption by stating
that a set of classes may have overlapping instances. Rows containing
overlap blocks take the form
\begin{itemize}
\item[] 
  \begin{tabular}{|l|l|l|l|l|}\hline
    \texttt{overlap} & $c_1$ & $c_2$ & \dots & $c_n$ \\ \hline 
  \end{tabular} \hfill ($n \ge 2$)
\end{itemize}
stating that each class $c_i$ is allowed to share instances with each
class $c_j$, for $1 \le i,j \le n$. In particular, a given $c_i$ and
$c_j$ in an overlap block are not defined to be disjoint classes in
the current ontology. As an example, consider the following entity
blocks that define the classes Estuary, Lagoon, and Marsh as
subclasses of Ecological Habitats.
begin
\begin{tabbing}
  ~~\texttt{entity} \texttt{EcologicalHabitat} \texttt{Estuary} \\ 
  ~~\texttt{entity} \texttt{EcologicalHabitat} \texttt{Lagoon} \\ 
  ~~\texttt{entity} \texttt{EcologicalHabitat} \texttt{Marsh} \\ 
\end{tabbing}
Given only these blocks, \owlifier\ treats Estuary, Lagoon, and Marsh
as disjoint classes. To relax this assumption and allow, e.g., types
of Lagoons to also be types of Estuaries, we explicitly add the
following overlap block
\begin{tabbing}
  ~~\texttt{overlap} \texttt{Estuary} \texttt{Lagoon}
\end{tabbing}
In general, overlap blocks are rarely used but provide a mechanism to
override the default behavior of \owlifier\ in asserting disjoint
classes.


\myblock{Relationship Blocks.} Relationship blocks define
\emph{required} object properties of classes. An object property
within OWL is a property defined between two class instances. Rows
containing relationship blocks take the form
\begin{itemize}
\item[]
  \begin{tabular}{|l|l|l|l|l|l|}\hline \texttt{relationship} & $p$ & $c_1$
    & $c_2$ & \dots & $c_n$ \\ \hline
  \end{tabular} \hfill ($n \ge 2$)
\end{itemize}
where $p$ is an object property and each $c_i$ is a class, for $1 \le
i \le n$.  For every class $c_i$, the relationship block induces the
DL axiom $c_i \sqsubseteq \exists p . c_{i+1}$ stating that each
instance of $c_i$ has, amongst possibly other things, a relationship
through $p$ to some instance of $c_{i+1}$.  For example, the following
block states that the class California Voles live in Grassy Areas.
\begin{tabbing}
  ~~\texttt{relationship} \texttt{livesIn} \texttt{CaliforniaVole} 
    \texttt{GrassyArea}
\end{tabbing}
In some cases, a particular property can apply to a sequence of
classes, and for convenience, each such class can be specified in a
single block. For example, consider the following block.
\begin{tabbing}
  ~~\texttt{relationship} \texttt{directlyBelow} \texttt{Hypolimnion} 
    \texttt{Thermocline} \texttt{Epilimnion} 
\end{tabbing}
This block states that, e.g., within a thermally stratified lake, the
Hypolimnion layer is directly below the Thermocline layer, and the
Thermocline layer is directly below the Epilimnion layer. 

\myblock{Transitive Blocks.} Transitive blocks are special cases of
relationship blocks in which the object property is asserted to be
transitive. That is, if $p$ is a transitive property from individuals
$o_1$ to $o_2$ and from $o_2$ to $o_3$, then $p$ is also assumed to be
from $o_1$ to $o_3$. Rows containing transitive blocks take the form
\begin{itemize}
\item[]
  \begin{tabular}{|l|l|l|l|l|l|}\hline \texttt{transitive} & $p$ & $c_1$
    & $c_2$ & \dots & $c_n$ \\ \hline
  \end{tabular} \hfill ($n \ge 2$)
\end{itemize}
where $p$ is an object property and each $c_i$ is a class, for $1 \le
i \le n$. As a simple example, the following transitive block
\begin{tabbing}
  ~~\texttt{transitive} \texttt{hasPart} \texttt{Body}
  \texttt{Head} \texttt{Eye} \texttt{Retina}
\end{tabbing} 
states that every Body has a Head as a part, every Head has an Eye as
a part, and every Eye has a Retina as a part. Moreover, because the
part-of property here is defined to be transitive, it is possible to
infer that every Body also has an Eye and a Retina.


\myblock{Attribute Blocks.} Attribute blocks define required
\emph{datatype} properties of concepts. Unlike object properties, a
datatype property within OWL is a property defined between a class
instance and a literal value (e.g., string, integer, etc.). Rows
containing attribute blocks take the form
\begin{itemize}
\item[]
  \begin{tabular}{|l|l|l|l|l|l|l|}\hline \texttt{attribute} & $p$ & $c_1$
    & $c_2$ & \dots & $c_n$ \\ \hline
  \end{tabular} \hfill ($n \ge 1$)
\end{itemize}
where $p$ is a datatype property and $c_i$ is a class, for $1 \le i
\le n$. For each concept $c_i$, the attribute block induces the
description logic axiom $c_i \sqsubseteq \exists p$ stating that each
instance of $c_i$ has, amongst possibly other things, a property $p$
with a literal value. As an example, the following ...


\myblock{Value Blocks.} Value blocks define required datatype property
\emph{constant values} for concepts. A value block has the form
\begin{itemize}
\item[]
  \begin{tabular}{|l|l|l|l|l|l|l|}\hline \texttt{value} & $P$ & $V$ & $C_1$
    & $C_2$ & \dots & $C_n$ \\ \hline
  \end{tabular} \hfill ($n \ge 1$)
\end{itemize}
where $P$ is a datatype property, $C_i$ is a concept for $1 \le i \le
n$, and $V$ is a datatype value. For each concept $C_i$, the value
block induces the DL axiom \[C_i \sqsubseteq (V \in P)\] stating that
each instance of $C_i$ has a value $V$ for property $P$.  The value
restrictions stated by value blocks are often used for defining
so-called \emph{value partitions} \cite{co-ode}.


\myblock{Inverse Blocks.} Inverse blocks state that two object
properties are inverses of each other. That is, for inverse properties
$P_1$ and $P_2$ and concept instances $O_1$ and $O_2$, if $P_1(O_1) =
O_2$, then $P_2(O_2) = O_1$.  An inverse block has the form
\begin{itemize}
\item[]
  \begin{tabular}{|l|l|l|}\hline \texttt{inverse} & $P_1$ & $P_2$
\\ \hline
  \end{tabular}
\end{itemize}
where $P_1$ and $P_2$ are object properties. 

\myblock{Minimum Blocks.} Minimum blocks state the minimum number of
properties $P$ an instance of a concept may have.  Minimum blocks have
the form
\begin{itemize}
\item[]
  \begin{tabular}{|l|l|l|l|l|l|l|}\hline \texttt{minimum} & $P$ & $N$ & 
    $C_1$ & $C_2$ & $\dots$ & $C_m$
    \\ \hline
  \end{tabular}
\end{itemize}
where $N$ is the minimum number of properties $P$ that instances of
concept $C_1$ may have to instances of concept $C_2$, $C_2$ to $C_3$,
and so on. A cardinality block induces the DL axiom \[C_i \sqsubseteq
(\le N P.C_{i+1})\] stating that each instance of $C_i$ must be related to
at least $N$ unique instances of $C_{i+1}$ via $P$. For example, the blocks
\begin{quote}
\texttt{minimum} \texttt{hasPart} 1 \texttt{Body} \texttt{Head} \\
\texttt{minimum} \texttt{hasPart} 2 \texttt{Head} \texttt{Eye}
\end{quote}
states that a body has at least one head and at least two eyes.


\myblock{Maximum Blocks.} Maximum blocks state the maximum
number of properties $P$ an instance of a concept may have.
Maximum blocks have the form
\begin{itemize}
\item[]
  \begin{tabular}{|l|l|l|l|l|l|l|}\hline \texttt{maximum} & $P$ & $N$ & 
    $C_1$ & $C_2$ & $\dots$ & $C_m$
    \\ \hline
  \end{tabular}
\end{itemize}
where $N$ is the maximum number of properties $P$ that instances of
concept $C_1$ may have to instances of concept $C_2$, $C_2$ to $C_3$,
and so on. A cardinality block induces the DL axiom \[C_i \sqsubseteq
(\ge N P.C_{i+1})\] stating that each instance of $C_i$ may be related to
at most $N$ unique instances of $C_{i+1}$ via $P$. For example, the blocks
\begin{quote}
\texttt{maximum} \texttt{hasPart} 1 \texttt{Body} \texttt{Head} \\
\texttt{maximum} \texttt{hasPart} 2 \texttt{Head} \texttt{Eye}
\end{quote}
states that a body has at least one head and at least two eyes.


\myblock{Sufficient Blocks.} Sufficient blocks state that any instance
having a property $P$ to an instance of a concept $C_2$ is a
sufficient condition for being an instance of a concept $C_1$. A
sufficient block has the form
\begin{itemize}
\item[]
  \begin{tabular}{|l|l|l|l|}\hline \texttt{sufficient} & $C_1$ & $P$ & $C_2$
    \\ \hline
  \end{tabular}
\end{itemize}
where $C_1$ is the target concept (i.e., denoting the concept
definition), $P$ is the sufficient property, and $C_2$ is the
sufficient concept. A sufficient block induces the DL axiom \[C_1
\equiv \exists P.C_2\] Sufficient blocks provide a mechansism to
construct simple class definitions (i.e., classes defined precisely by
other classes), primarily for use with value partitions. [NOTE: these
should be anded together?]


\myblock{Description Blocks.} Description blocks assign plain-text
definitions to concepts and properties. A description block has the
form
\begin{itemize}
\item[]
  \begin{tabular}{|l|l|l|}\hline \texttt{description} & $T$ & $S$
    \\ \hline
  \end{tabular}
\end{itemize}
where $T$ is either a property or a concept and $S$ is a description
string.


\myblock{Note Blocks.} Note blocks add comments to the current
ontology, and are ignored by \owlifier.  A note block has the form
\begin{itemize}
\item[]
  \begin{tabular}{|l|l|l|}\hline \texttt{note} & $S$
\\ \hline
  \end{tabular}
\end{itemize}
where $S$ is a comment string.


*** Say something about relaxing block syntax ... to make it easier to
specify ontologies. Also, allow blocks to be given in any order.


\section{\owlifier\ Properties and Reasoning}
\label{sec:properties}


Some desirable properties: 
\begin{itemize}
\item non-ambiguous (no block leads to ambiguous DL axioms)
\item ``reasonable'' (not everything has to be explicitly stated)
\item ???
\end{itemize}

\section{\owlifier\ Implementation}
\label{sec:implementation}

Flags: 
\begin{itemize}
\item delimeter characters 
\item perform classification
\item warnings
\item owlifier to owl and owl to owlifier
\item ??? 
\end{itemize}


\section{Conclusion}
\label{sec:conclusion}



%\bibliographystyle{elsarticle-num}
\bibliographystyle{abbrv}
\bibliography{main}


\end{document}

