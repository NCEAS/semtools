\documentclass[preprint,number]{elsarticle} 
% other options: preprint, review, 1p, 3p, 5p, 
% bib options: authoryear, number, longtitle,
% other options: times


\newcommand{\Owlifier}{\textsf{Owlifier}}
\newcommand{\owlifier}{\textsf{owlifier}}

\newcommand{\myblock}[1]{\vspace{12pt}\noindent\textbf{#1}}

\newcommand{\secref}[1]{Section~\ref{#1}}
\newcommand{\figref}[1]{Figure~\ref{#1}}

\title{Owlifier: Creating OWL-DL Ontologies from Simple
  Spreadsheet-Based Knowledge Descriptions\tnoteref{t1}}
%\tnotetext[t1]{This work supported in part by NSF grants ...}

\author[smb]{Shawn Bowers\corref{cor1}}
\ead{sbowers@ucdavis.edu}

\author[jsm]{Joshua S. Madin}
\ead{jmadin@bio.mq.edu.au}

\author[mps]{Mark P. Schildhauer}
\ead[url]{schild@nceas.ucsb.edu}

\cortext[cor1]{Corresponding author}

\address[smb]{UC Davis Genome Center}

\address[jsm]{Dept. of Biological Sciences, Macquarie University, Australia}

\address[mps]{National Center for Ecological Analysis and Synthesis,
  UC Santa Barbara}



\begin{document}

\begin{abstract}
  Discovery and integration of data is important in many ecological
  studies, especially those that concern broad-scale ecological
  questions. Discovery and integration is often a difficult and
  time-consuming task for researchers, in part because informal,
  ambiguous, and sometimes inconsistent terms are used to describe
  data semantics.  Ontologies can help address this problem by
  providing a means to define ecological concepts to more consistently
  annotate, relate, and search for data sets.
  %
  However, unlike in molecular biology or biomedicine, few ontology
  development efforts exist within ecology. Ontology development often
  requires considerable expertise in ontology languages and
  development tools, which is often a barrier for ontology creation in
  ecology. In this paper we address this problem by providing an
  approach for ontology creation that allows ecologists to use common
  spreadsheet tools to describe different aspects of an ontology.  We
  present conventions for creating, relating, and constraining
  concepts through spreadsheets, and provide software tools for
  converting these ontologies into equivalent OWL-DL
  representations. We also consider inverse translations, i.e., to
  convert ontologies represented using OWL-DL into our spreadsheet
  format. Our approach allows large lists of terms to be easily
  related and organized into concept hierarchies, and generally
   provides a more intuitive and natural interface for ontology
  development by ecologists.
\end{abstract}

\maketitle

\section{Introduction}

Within the fields of molecular biology and biomedicine considerable
effort has gone into developing ontologies for improving data
discovery and integration
\cite{bard04:_ontol_in_biolog,ashburner00:_gene_ontol}. While similar
benefits can be obtained for ecological data, far fewer efforts exist
to develop richer and more consistent terminologies of ecology
concepts
\cite{madin08:_advan_ecolog_resear_with_ontol,parr20:_data_sharin_in_ecolog_and_evolut}.
The use of formal ontologies can significantly enhance metadata
descriptions of ecological data. Annotating data with ontology terms
can both help users interpret data as well as enable advanced
capabilities for data discovery and integration, e.g., by exploiting
subsumption and part-of hierarchies as well as more formal constraints
such as cardinality restrictions on properties and term equivalence.

Efforts to engage scientists in the development of ontologies
typically leverage the W3C Web Ontology Language (OWL)
\cite{smith04:_owl_web_ontol_languag_guide} as a standard XML syntax
for representing and sharing ontologies. A key advantage of OWL is
that it is supported by a wide range of generic tools, including
editors
\cite{knublauch04:_editin_descr_logic_ontol_with,kalyanpur05:_swoop},
reasoning systems
\cite{sirin07:_pellet,tsarkov06:_fact_descr_logic_reason}, query
languages
\cite{prudhommeaux08:_sparq_query_languag_for_rdf,motik05:_query_answer_for_owl_dl_with_rules},
and storage technologies
\cite{carroll04:_jena,broekstra02:_sesam}. Most of these tools,
however, are primarily targeted at experts in knowledge engineering
and software development familiar with the underlying description
logic semantics of OWL-DL \cite{grau08:_owl}. This is especially true
with ontology editors (such as Protege, SWOOP, etc.), which allow for
very detailed ontology specifications, but at the same time require
considerable understanding of the underlying ontology formalisms and
syntax. Thus, we see the lack of suitable ontology editing tools for
scientists as one of the major barriers for more wide-scale adoption
of ontologies in ecology.


This paper presents a novel approach for ontology creation that aims
at being more intuitive for ecologists and that can be used to rapidly
construct large ontologies for describing scientific data. Our
approach is to allow scientists to use common spreadsheet-based tools
to describe, in an intuitive way, different aspects of an ontology,
and then to take these descriptions and convert them into full-fledged
OWL ontologies using a software application called \owlifier. An
\owlifier\ spreadsheet consists of a set of \emph{blocks} that have a
predefined template structure for users to fill in. Each non-empty row
in an \owlifier\ table constitutes a block. Each block defines
different aspects of an ontology including ontology classes,
subclasses, synonyms, and properties.  We also provide blocks for
plain-text descriptions of classes and properties, and for referencing
one or more existing ontologies (e.g., to extend an existing ontology
or to define ontology articulations). Blocks can be sparse (inheriting
from previous blocks), which can further simplify the creation of
large ontologies.

While not as expressive as OWL-DL, our approach can produce ontology
structures essential for enhanced data discovery and integration
\cite{madin07:_ontol_for_descr_and_synth}, while at the same time
provide a more accessible user interface for ecologists. Further, our
approach can be used to rapidly construct class hierarchies from long
lists of keywords using familiar spreadsheet software. For instance,
an ecologist can easily list (or import) a set of terms, and then
incrementally organize these into class hierarchies, and define
relevant properties and their constraints. Based on our experiences
using \owlifier\ with ecologists and evolutionary biologists studying
trait data, we found that this approach can enable them to quickly and
easily comprehend and construct useful ontologies.

The rest of this paper is organized as follows. In
\secref{sec:owlifier} we describe the basic syntax and semantics of
\owlifier. We define blocks that support a large subset of OWL-DL and
that also generally follow the ontology creation guidelines defined in
\cite{rector04:_owl_pizzas}. We also simplify certain aspects of
ontology creation using OWL-DL, e.g., by assuming classes are disjoint
by default (unless specified otherwise) and by applying implicit
property restriction closures \cite{rector04:_owl_pizzas}. In
\secref{sec:characteristics} we describe additional characteristics of
\owlifier\ and discuss issues with respect to classification and
reasoning. In \secref{sec:implementation} we briefly describe the
\owlifier\ implementation, and conlcude in \secref{sec:conclusion}
with related and future work. In general, the goal of \owlifier\ is
not to support all constructs in OWL-DL, but instead to provide a
higher-level ontology syntax (via spreadsheet blocks) that is easy for
ecologists to use and understand while also providing the necessary
constructs for developing typical ecological ontologies. By compiling
\owlifier\ to OWL-DL, we also allow for experts to refine and extend
the ontology using more advanced ontology editing tools if necessary.



\section{The Syntax and Semantics of \Owlifier}
\label{sec:owlifier}

An \owlifier\ table defines an OWL-DL
\cite{smith04:_owl_web_ontol_languag_guide} ontology through a set of
\emph{blocks} representing one or more ontology definitions.  Each
non-empty row in an \owlifier\ table corresponds to a block. The type
of the block is given in the first column of the row. We describe each
type of block supported by \owlifier\ below. Here we assume that if
any properties or classes used in a block are not imported from
another ontology, then they are to be added to the ontology being
specified by the \owlifier\ table. In general, we name blocks
according to the more generic terms used in
\cite{bowers08:_concep_model_framew_for_expres,madin07:_ontol_for_descr_and_synth}
instead of those of OWL-DL. This allows \owlifier\ to generate
ontologies that extend the observational model of
\cite{bowers08:_concep_model_framew_for_expres,madin07:_ontol_for_descr_and_synth}
for data annotation, and in certain cases avoids confusion with
established terms commonly used within ecology.

\myblock{Import Blocks.} Import blocks assign namespace labels to
external ontologies. Each external ontology is imported into the
current ontology. We refer to the ontologies of import blocks as
\emph{imported ontologies}.  Using import blocks, classes and
properties of imported ontologies can be used within other blocks of
an \owlifier\ table.  Rows containing import blocks take the form
\begin{itemize}
\item[]
  \begin{tabular}{|l|l|l|}\hline
    \textsf{import} & $n$ & $u$ \\ \hline 
  \end{tabular} 
\end{itemize}
where $n$ is a namespace label and $u$ is an OWL ontology URI. Classes
and properties from imported ontologies are referenced by prefixing
the namespace label $n$ to the corresponding class or property name in
the normal way. As an example, the following block imports the SWEET
``Earth Realm'' ontology \cite{raskin:_seman_web_for_earth_and}
\begin{tabbing}
  ~~\textsf{import}  \textsf{sweet} 
  \textsf{http://sweet.jpl.nasa.gov/ontology/earthrealm.owl}
\end{tabbing}
With this import block the class denoting Marine Ecosystems (a class
defined in the SWEET ontology) can be referred to from within an
\owlifier\ table using the expression
\textsf{sweet:MarineEcosystem}. Because this class refers to a class
in another ontology, we refer to it as an \emph{imported class}.


\myblock{Entity Blocks.} Entity blocks are the primary blocks used to
define ontologies. An entity block introduces new OWL classes and
specifies subclass relationships. Imported classes may also be used
within entity blocks by prefixing class names with namespace labels
(as described above).  Rows containing entity blocks take the form
\begin{itemize}
\item[] 
  \begin{tabular}{|l|l|l|l|l|}\hline
    \textsf{entity} & $c_1$ & $c_2$ & \dots & $c_n$ \\ \hline 
  \end{tabular} \hfill ($n \ge 1$)
\end{itemize}
where each class $c_i$ is asserted in the current ontology to subsume
$c_{i+1}$, for $1 \le i < n$. That is, each $c_i$ in an entity block
induces the description-logic axiom $c_{i+1} \sqsubseteq c_i$.  If
both $c_i$ and $c_{i+1}$ are imported classes, we say that the block
defines an ``articulation'' (i.e., mapping) between the two
classes. The following entity block defines a simple subclass
hierarchy.
\begin{tabbing}
  ~~\textsf{entity} \textsf{PhysicalFeature} 
    \textsf{AquaticPhysicalFeature} \textsf{River}
\end{tabbing}
This block states that Physical Feature, Aquatic Physical Feature, and
River are classes; River is a subclass of Aquatic Physical Feature;
and Aquatic Physical Feature is a subclass of Physical Feature. The
following entity block introduces a new class via an imported class.
\begin{tabbing}
  ~~\textsf{entity} \textsf{sweet:MarineEcosystem} 
    \textsf{IntertidalEcosystem}
\end{tabbing}
This block states that Intertidal Ecosystem is a subclass of the
Marine Ecosystem class imported from the SWEET ontology. Similarly,
assuming ``marine'' denotes an existing ontology of marine ecosystem
concepts, the following entity block defines a simple class
articulation.
\begin{tabbing}
  ~~\textsf{entity} \textsf{sweet:MarineEcosystem} 
    \textsf{marine:DeapSeaEcosystem}
\end{tabbing}
This block states that the Deap Sea Ecosystem class of the marine
ontology is a subclass of the Marine Ecosystem class of the SWEET
ontology.

\myblock{Synonym Blocks.} Synonym blocks define equivalence
relationships between ontology classes.  Rows containing synonym
blocks take the form
\begin{itemize}
\item[] 
  \begin{tabular}{|l|l|l|l|l|}\hline
    \textsf{synonym} & $c_1$ & $c_2$ & \dots & $c_n$ \\ \hline 
  \end{tabular} \hfill ($n \ge 2$)
\end{itemize}
where each class $c_i$ is equivalent to class $c_{i+1}$ in the current
ontology, for $1 \le i < n$. That is, each $c_i$ in a synonym blocks
induces a description logic axiom of the form $c_i \equiv
c_{i+1}$. The following synonym block defines a simple equivalence
relationship.
\begin{tabbing}
  ~~\textsf{synonym} \textsf{Maize} \textsf{Corn}
\end{tabbing}
This block states that the Maize and Corn classes are synonyms, i.e.,
equivalent classes. Similar to entity blocks, synonym blocks often
contain imported classes, e.g., to extend an existing ontology or to
define ontology articulations.


\myblock{Overlap Blocks.} Except in certain situations (described
further in \secref{sec:characteristics}), classes are generally
assumed to be disjoint in \owlifier.  Overlap blocks explicitly relax
this assumption by stating that a give set of classes may have
overlapping instances. Rows containing overlap blocks take the form
\begin{itemize}
\item[] 
  \begin{tabular}{|l|l|l|l|l|}\hline
    \textsf{overlap} & $c_1$ & $c_2$ & \dots & $c_n$ \\ \hline 
  \end{tabular} \hfill ($n \ge 2$)
\end{itemize}
where each class $c_i$ is allowed to share instances with each class
$c_j$, for $1 \le i,j \le n$. In particular, a given $c_i$ and $c_j$
in an overlap block are not defined to be disjoint classes in the
current ontology. As an example, consider the following entity blocks
that define the classes Estuary, Lagoon, and Marsh as subclasses of
Ecological Habitats.
\begin{tabbing}
  ~~\textsf{entity} \textsf{EcologicalHabitat} \textsf{Estuary} \\ 
  ~~\textsf{entity} \textsf{EcologicalHabitat} \textsf{Lagoon} \\ 
  ~~\textsf{entity} \textsf{EcologicalHabitat} \textsf{Marsh} 
\end{tabbing}
Given only these blocks, \owlifier\ treats Estuary, Lagoon, and Marsh
as disjoint classes. To relax this assumption and allow, e.g., types
of Lagoons to also be types of Estuaries, we explicitly add the
following overlap block
\begin{tabbing}
  ~~\textsf{overlap} \textsf{Estuary} \textsf{Lagoon}
\end{tabbing}
In general, overlap blocks are rarely used but provide a mechanism to
override the default behavior of \owlifier\ in asserting disjoint
classes.


\myblock{Relationship Blocks.} Relationship blocks define
\emph{required} object properties of classes. An object property
within OWL is a property defined between two class instances. Rows
containing relationship blocks take the form
\begin{itemize}
\item[]
  \begin{tabular}{|l|l|l|l|l|l|}\hline \textsf{relationship} & $p$ & $c_1$
    & $c_2$ & \dots & $c_n$ \\ \hline
  \end{tabular} \hfill ($n \ge 2$)
\end{itemize}
where $p$ is an object property and each $c_i$ is a class, for $1 \le
i \le n$.  For every class $c_i$, the relationship block induces the
DL axiom $c_i \sqsubseteq \exists p . c_{i+1}$ stating that each
instance of $c_i$ has, amongst possibly other things, a relationship
through $p$ to some instance of $c_{i+1}$.  For example, the following
block states that the class California Voles live in Grassy Areas.
\begin{tabbing}
  ~~\textsf{relationship} \textsf{livesIn} \textsf{CaliforniaVole} 
    \textsf{GrassyArea}
\end{tabbing}
In some cases, a particular property can apply to a sequence of
classes, and for convenience, each such class can be specified in a
single block. For example, consider the following block.
\begin{tabbing}
  ~~\textsf{relationship} \textsf{directlyBelow} \textsf{Hypolimnion} 
    \textsf{Thermocline} \textsf{Epilimnion} 
\end{tabbing}
This block states that, e.g., within a thermally stratified lake, the
Hypolimnion layer is directly below the Thermocline layer, and the
Thermocline layer is directly below the Epilimnion layer. 

\myblock{Transitive Blocks.} Transitive blocks are special cases of
relationship blocks where the object property is asserted to be
transitive. If a property $p$ is declared to be transitive, whenever
$p$ relates an individual $o_1$ to an individual $o_2$, and an
individual $o_2$ to an individual $o_3$, then $p$ is also assumed to
relate $o_1$ to $o_3$. Rows containing transitive blocks take the form
\begin{itemize}
\item[]
  \begin{tabular}{|l|l|l|l|l|l|}\hline \textsf{transitive} & $p$ & $c_1$
    & $c_2$ & \dots & $c_n$ \\ \hline
  \end{tabular} \hfill ($n \ge 2$)
\end{itemize}
where $p$ is an object property and each $c_i$ is a class, for $1 \le
i \le n$. The following block is a simple example of a transitive
relationship. 
\begin{tabbing}
  ~~\textsf{transitive} \textsf{hasPart} \textsf{Body}
  \textsf{Head} \textsf{Eye} \textsf{Retina}
\end{tabbing} 
This block states that every Body has a Head as a part, every Head has
an Eye as a part, and every Eye has a Retina as a part. Moreover,
because the part-of property here is defined to be transitive, it is
possible to infer that every Body also has an Eye and a Retina through
the corresponding relationship restrictiosn, i.e., $\textsf{Body}
\sqsubseteq \exists \textsf{hasPart} . \textsf{Head}$, $\textsf{Head}
\sqsubseteq \exists \textsf{hasPart} . \textsf{Eye}$, and
$\textsf{Eye} \sqsubseteq \exists \textsf{hasPart} . \textsf{Retina}$.


\myblock{Inverse Blocks.} Inverse blocks state that two object
properties are inverses of each other. If $p_1$ and $p_2$ are defined
to be inverse properties, whenever $p_1$ relates an individual $o_1$
to an individual $o_2$ then $p_2$ is assumd to relate $o_2$ to $o_1$.
Rows containing inverse blocks take the form
\begin{itemize}
\item[]
  \begin{tabular}{|l|l|l|}\hline \textsf{inverse} & $p_1$ & $p_2$
\\ \hline
  \end{tabular}
\end{itemize}
where $p_1$ and $p_2$ are object properties. A common example of
inverse properties are \texttt{partOf} and \texttt{hasPart}.

\myblock{}*** HERE *** 

\myblock{Attribute Blocks.} Attribute blocks define required
\emph{datatype} properties of concepts. Unlike object properties, a
datatype property within OWL is a property defined between a class
instance and a literal value (e.g., string, integer, etc.). Rows
containing attribute blocks take the form
\begin{itemize}
\item[]
  \begin{tabular}{|l|l|l|l|l|l|l|}\hline \textsf{attribute} & $p$ & $c_1$
    & $c_2$ & \dots & $c_n$ \\ \hline
  \end{tabular} \hfill ($n \ge 1$)
\end{itemize}
where $p$ is a datatype property and $c_i$ is a class, for $1 \le i
\le n$. For each concept $c_i$, the attribute block induces the
description logic axiom $c_i \sqsubseteq \exists p$ stating that each
instance of $c_i$ has, amongst possibly other things, a property $p$
with a literal value. As an example, the following ...


\myblock{Value Blocks.} Value blocks define required datatype property
\emph{constant values} for concepts. A value block has the form
\begin{itemize}
\item[]
  \begin{tabular}{|l|l|l|l|l|l|l|}\hline \textsf{value} & $P$ & $V$ & $C_1$
    & $C_2$ & \dots & $C_n$ \\ \hline
  \end{tabular} \hfill ($n \ge 1$)
\end{itemize}
where $P$ is a datatype property, $C_i$ is a concept for $1 \le i \le
n$, and $V$ is a datatype value. For each concept $C_i$, the value
block induces the DL axiom \[C_i \sqsubseteq (V \in P)\] stating that
each instance of $C_i$ has a value $V$ for property $P$.  The value
restrictions stated by value blocks are often used for defining
so-called \emph{value partitions} \cite{co-ode}.



\myblock{Minimum Blocks.} Minimum blocks state the minimum number of
properties $P$ an instance of a concept may have.  Minimum blocks have
the form
\begin{itemize}
\item[]
  \begin{tabular}{|l|l|l|l|l|l|l|}\hline \textsf{minimum} & $P$ & $N$ & 
    $C_1$ & $C_2$ & $\dots$ & $C_m$
    \\ \hline
  \end{tabular}
\end{itemize}
where $N$ is the minimum number of properties $P$ that instances of
concept $C_1$ may have to instances of concept $C_2$, $C_2$ to $C_3$,
and so on. A cardinality block induces the DL axiom \[C_i \sqsubseteq
(\le N P.C_{i+1})\] stating that each instance of $C_i$ must be related to
at least $N$ unique instances of $C_{i+1}$ via $P$. For example, the blocks
\begin{quote}
\textsf{minimum} \textsf{hasPart} 1 \textsf{Body} \textsf{Head} \textsf{Nose}\\
\textsf{minimum} \textsf{hasPart} 2 \textsf{Head} \textsf{Eye}
\end{quote}
states that a body has at least one head and at least two eyes.


\myblock{Maximum Blocks.} Maximum blocks state the maximum
number of properties $P$ an instance of a concept may have.
Maximum blocks have the form
\begin{itemize}
\item[]
  \begin{tabular}{|l|l|l|l|l|l|l|}\hline \textsf{maximum} & $P$ & $N$ & 
    $C_1$ & $C_2$ & $\dots$ & $C_m$
    \\ \hline
  \end{tabular}
\end{itemize}
where $N$ is the maximum number of properties $P$ that instances of
concept $C_1$ may have to instances of concept $C_2$, $C_2$ to $C_3$,
and so on. A cardinality block induces the DL axiom \[C_i \sqsubseteq
(\ge N P.C_{i+1})\] stating that each instance of $C_i$ may be related to
at most $N$ unique instances of $C_{i+1}$ via $P$. For example, the blocks
\begin{quote}
\textsf{maximum} \textsf{hasPart} 1 \textsf{Body} \textsf{Head} \\
\textsf{maximum} \textsf{hasPart} 2 \textsf{Head} \textsf{Eye}
\end{quote}
states that a body has at least one head and at least two eyes.


\myblock{Sufficient Blocks.} Sufficient blocks state that any instance
having a property $P$ to an instance of a concept $C_2$ is a
sufficient condition for being an instance of a concept $C_1$. A
sufficient block has the form
\begin{itemize}
\item[]
  \begin{tabular}{|l|l|l|l|}\hline \textsf{sufficient} & $C_1$ & $P$ & $C_2$
    \\ \hline
  \end{tabular}
\end{itemize}
where $C_1$ is the target concept (i.e., denoting the concept
definition), $P$ is the sufficient property, and $C_2$ is the
sufficient concept. A sufficient block induces the DL axiom \[C_1
\equiv \exists P.C_2\] Sufficient blocks provide a mechansism to
construct simple class definitions (i.e., classes defined precisely by
other classes), primarily for use with value partitions. [NOTE: these
should be anded together?]


\myblock{Description Blocks.} Description blocks assign plain-text
definitions to concepts and properties. A description block has the
form
\begin{itemize}
\item[]
  \begin{tabular}{|l|l|l|}\hline \textsf{description} & $T$ & $S$
    \\ \hline
  \end{tabular}
\end{itemize}
where $T$ is either a property or a concept and $S$ is a description
string.


\myblock{Note Blocks.} Note blocks add comments to the current
ontology, and are ignored by \owlifier.  A note block has the form
\begin{itemize}
\item[]
  \begin{tabular}{|l|l|l|}\hline \textsf{note} & $S$
\\ \hline
  \end{tabular}
\end{itemize}
where $S$ is a comment string.



\section{Additional Characteristics of \Owlifier}
\label{sec:characteristics}


Some desirable properties: 
\begin{itemize}
\item non-ambiguous (no block leads to ambiguous DL axioms)
\item ``reasonable'' (not everything has to be explicitly stated)
\item ???
\end{itemize}


*** Say something about relaxing block syntax ... to make it easier to
specify ontologies. Also, allow blocks to be given in any order.

\section{Implementation of \Owlifier}
\label{sec:implementation}

Flags: 
\begin{itemize}
\item delimeter characters 
\item perform classification
\item warnings
\item owlifier to owl and owl to owlifier
\item ??? 
\end{itemize}


\section{Conclusion}
\label{sec:conclusion}



%\bibliographystyle{elsarticle-num}
\bibliographystyle{abbrv}
\bibliography{main}


\end{document}

