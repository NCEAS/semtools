\documentclass[preprint,number]{elsarticle} 
% other options: preprint, review, 1p, 3p, 5p, 
% bib options: authoryear, number, longtitle,
% other options: times


\newcommand{\Owlifier}{\textsf{Owlifier}}
\newcommand{\owlifier}{\textsf{owlifier}}
\newcommand{\mypara}[1]{\vspace{12pt}\noindent\textbf{#1}}

\newcommand{\secref}[1]{Sect.~\ref{#1}}
\newcommand{\figref}[1]{Fig.~\ref{#1}}

\title{Owlifier: Creating OWL-DL Ontologies from Simple
  Spreadsheet-Based Knowledge Descriptions\tnoteref{t1}}
%\tnotetext[t1]{This work supported in part by NSF grants ...}

\author[smb]{Shawn Bowers\corref{cor1}}
\ead{sbowers@ucdavis.edu}

\author[jsm]{Joshua S. Madin}
\ead{jmadin@bio.mq.edu.au}

\author[mps]{Mark P. Schildhauer}
\ead[url]{schild@nceas.ucsb.edu}

\cortext[cor1]{Corresponding author}

\address[smb]{UC Davis Genome Center}

\address[jsm]{Dept. of Biological Sciences, Macquarie University, Australia}

\address[mps]{National Center for Ecological Analysis and Synthesis,
  UC Santa Barbara}



\begin{document}

\begin{abstract}
  Discovery and integration of data is important in many ecological
  studies, especially those that concern broad-scale ecological
  questions. Discovery and integration is often a difficult and
  time-consuming task for researchers, in part because informal,
  ambiguous, and sometimes inconsistent terms are used to describe
  data semantics.  Ontologies can help address this problem by
  providing a means to define ecological concepts to more consistently
  annotate, relate, and search for data sets.
  %
  However, unlike in molecular biology or biomedicine, few ontology
  development efforts exist within ecology. Ontology development often
  requires considerable expertise in ontology languages and
  development tools, which is often a barrier for ontology creation in
  ecology. In this paper we address this problem by providing an
  approach for ontology creation that allows ecologists to use common
  spreadsheet tools to describe different aspects of an ontology.  We
  present conventions for creating, relating, and constraining
  concepts through spreadsheets, and provide software tools for
  converting these ontologies into equivalent OWL-DL
  representations. We also consider inverse translations, i.e., to
  convert ontologies represented using OWL-DL into our spreadsheet
  format. Our approach allows large lists of terms to be easily
  related and organized into concept hierarchies, and generally
   provides a more intuitive and natural interface for ontology
  development by ecologists.
\end{abstract}

\maketitle

\section{Introduction}

Within the fields of molecular biology and biomedicine considerable
effort has gone into developing ontologies for improving data
discovery and integration
\cite{bard04:_ontol_in_biolog,ashburner00:_gene_ontol}. While similar
benefits can be obtained for ecological data, far fewer efforts exist
to develop richer and more consistent terminologies of ecology
concepts
\cite{madin08:_advan_ecolog_resear_with_ontol,parr20:_data_sharin_in_ecolog_and_evolut}.
The use of formal ontologies can significantly enhance metadata
descriptions of ecological data. Annotating data with ontology terms
can both help users interpret data as well as enable advanced
capabilities for data discovery and integration, e.g., by exploiting
subsumption and part-of hierarchies as well as more formal constraints
such as cardinality restrictions on properties and term equivalence.

Efforts to engage scientists in the development of ontologies
typically leverage the W3C Web Ontology Language (OWL)
\cite{smith04:_owl_web_ontol_languag_guide} as a standard XML syntax
for representing and sharing ontologies. A key advantage of OWL is
that it is supported by a wide range of generic tools, including
editors
\cite{knublauch04:_editin_descr_logic_ontol_with,kalyanpur05:_swoop},
reasoning systems
\cite{sirin07:_pellet,tsarkov06:_fact_descr_logic_reason}, query
languages
\cite{prudhommeaux08:_sparq_query_languag_for_rdf,motik05:_query_answer_for_owl_dl_with_rules},
and storage technologies
\cite{carroll04:_jena,broekstra02:_sesam}. Most of these tools,
however, are primarily targeted at experts in knowledge engineering
and software development familiar with the underlying description
logic semantics of OWL-DL \cite{grau08:_owl}. This is especially true
with ontology editors (such as Protege, SWOOP, etc.), which allow for
very detailed ontology specifications, but at the same time require a
considerable amount of understanding of the underlying ontology
formalisms and syntax. Thus, we see the lack of suitable ontology
editing tools for scientists as one of the major barriers for more
wide-scale adoption of ontologies in ecology.


This paper presents a novel approach for ontology creation that aims
at being more intuitive for ecologists and that can be used to rapidly
construct large ontologies for describing scientific data. Our
approach is to allow scientists to use common spreadsheet-based tools
to describe, in an intuitive way, different aspects of an ontology,
and then to take these descriptions and convert them into full-fledged
OWL ontologies using a software application called \owlifier. An
\owlifier\ spreadsheet consists of a set of \emph{blocks} that have a
predefined template structure for users to fill in. Each non-empty row
in an \owlifier\ table constitutes a block. Each block defines
different aspects of an ontology including ontology classes,
subclasses, synonyms, and properties.  We also provide blocks for
plain-text descriptions of classes and properties, and for referencing
one or more existing ontologies (e.g., to extend an existing ontology
or to define ontology articulations). Blocks can be sparse (inheriting
from previous blocks), which can further simplify the creation of
large ontologies.

While not as expressive as OWL-DL, our approach can produce ontology
structures essential for enhanced data discovery and integration,
while at the same time provide a more accessible user interface for
ecologists. Further, our approach can be used to rapidly construct
class hierarchies from long lists of keywords using familiar
spreadsheet software. For instance, an ecologist can easily list (or
import) a set of terms, and then incrementally organize these into a
class hierarchy, define properties and constraints, etc. We have used
the \owlifier\ approach with ecologists and evolutionary biologists
working with trait data, and found that it enabled them to quickly and
easily comprehend and construct ontologies.

The rest of this paper is organized as follows. In
\secref{sec:owlifier} we describe the basic syntax and semantics of
\owlifier. We define blocks that support a large subset of OWL-DL and
that also generally follow the ontology creation guidelines defined in
\cite{rector04:_owl_pizzas}. We also simplify certain aspects of
ontology creation using OWL-DL, e.g., by assuming classes are disjoint
by default (unless specified otherwise) and by applying implicit
property restriction closures \cite{rector04:_owl_pizzas}. In
\secref{sec:properties} we describe additional characteristics of
\owlifier\ and discuss issues with respect to classification and
reasoning. In \secref{sec:implementation} we briefly describe the
\owlifier\ implementation, and conlcude in \secref{sec:conclusion}
with related and future work. In general, the goal of \owlifier\ is
not to support all constructs in OWL-DL, but instead to provide a
higher-level ontology syntax (via spreadsheet blocks) that is easy for
ecologists to use and understand while also providing the necessary
constructs for developing typical ecological ontologies. By compiling
\owlifier\ to OWL-DL, we also allow for experts to refine and extend
the ontology using more advanced ontology editing tools if necessary.



\section{\Owlifier\ Syntax and Semantics}
\label{sec:owlifier}

An \owlifier\ table defines an OWL-DL
\cite{smith04:_owl_web_ontol_languag_guide} ontology through a set of
\emph{blocks} representing one or more ontology definitions.  Each
non-empty row in an \owlifier\ table corresponds to a block. The type
of the block is given in the first column of the row. We describe each
type of block supported by \owlifier\ below. Here we assume that if
any of the properties or concepts used in a block are defined, i.e.,
are not imported from another ontology, then they are added to the
ontology being defined by the \owlifier\ table.

\mypara{Import Block.} Import blocks assign namespace labels to
external ontologies. Each external ontology is imported into the
current ontology. We refer to the ontologies of import blocks as
\emph{imported ontologies}.  Using import blocks, classes and
properties of imported ontologies can be used within other blocks of
an \owlifier\ table.  Import blocks take the form
\begin{itemize}
\item[]
  \begin{tabular}{|l|l|l|}\hline
    \texttt{import} & $\textit{N}$ & $\textit{U}$ \\ \hline 
  \end{tabular} 
\end{itemize}
where $\textit{N}$ is a namespace label and $\textit{U}$ is an OWL
ontology URI. Classes and properties from imported ontologies are
referenced by prefixing the namespace label $\textit{N}$ to the
corresponding class or property name in the normal way. The following
block imports the ``earth realm'' ontology from the set of SWEET
ontologies \cite{raskin:_seman_web_for_earth_and}
\begin{tabbing}
  ~~\texttt{import sweet
    http://sweet.jpl.nasa.gov/ontology/earthrealm.owl}
\end{tabbing}
where the ontology class denoting marine ecosystems can be refered to
from within the corresponding \owlifier\ table using the syntax, e.g.,
\sloppy\texttt{sweet:MarineEcosystem}. Because this class refers to a
class in another ontology, we call it an ``imported'' class.

\mypara{Entity Block.} Entity blocks introduce new OWL classes and
specify subclass relationships. Imported classes may also be used
within a concept block by prefixing the class name with a namespace
label, e.g., when an ontology is being extended.  We use the term
`entity to avoid confusion with the use of the term 'class' in
biological taxonomies and because `entity' is used in \cite{oboe} to
define ecological concepts. Entity blocks take the form
\begin{itemize}
\item[] 
  \begin{tabular}{|l|l|l|l|l|}\hline
    \texttt{entity} & $C_1$ & $C_2$ & \dots & $C_n$ \\ \hline 
  \end{tabular} \hfill ($n \ge 1$)
\end{itemize}
where each class $C_i$ is asserted in the current ontology to subsume
a class $C_{i+1}$, for $1 \le i < n$. Each $C_i$ in a concept block
induces the DL axiom \[C_i \sqsubseteq C_{i+1}.\] If both $C_i$ and
$C_{i+1}$ are imported classes, we say that the block defines an
``articulation'' (i.e., mapping) between the two classes. The
following concept block defines a simple subclass hierarchy
\begin{tabbing}
  ~~\texttt{entity PhysicalFeature AquaticPhysicalFeature River}
\end{tabbing}
which states that river is a subclass of aquatic physical feature and
that aquatic physical feature is a subclass of physical feature.

\mypara{Synonym Block.} Synonym blocks define an equivalence
relationship between classes.  A synonym block has the form
\begin{itemize}
\item[] 
  \begin{tabular}{|l|l|l|l|l|}\hline
    \texttt{synonym} & $C_1$ & $C_2$ & \dots & $C_n$ \\ \hline 
  \end{tabular} \hfill ($n \ge 2$)
\end{itemize}
where each class $C_i$ is asserted as being equivalent to class
$C_{i+1}$ in the current ontology, for $1 \le i < n$. For example, the
block
\begin{tabbing}
~~\texttt{synonym Maize Corn}
\end{tabbing}
defines maize and corn as synonym (i.e., equivalent) classes.


\mypara{Overlap Block} 

\mypara{}Except in certain situations (described further below),
classes are assumed to be disjoint.  Overlap blocks explicitly relax
this assumption for a given set of classes by stating that a set of
classes may have overlapping instances. An overlap block has the form
\begin{itemize}
\item[] 
  \begin{tabular}{|l|l|l|l|l|}\hline
    \texttt{overlap} & $C_1$ & $C_2$ & \dots & $C_n$ \\ \hline 
  \end{tabular} \hfill ($n \ge 2$)
\end{itemize}
where each class $C_i$ is allowed to share instances with each concept
$C_j$, for $1 \le i,j \le n$. In particular, $C_i$ and $C_j$ are not
defined to be disjoint classes in the current ontology. 

--- an example here ---


\mypara{Relationship Block}

\mypara{}Relationship blocks define required \emph{object} properties
of classes. A property block has the form
\begin{itemize}
\item[]
  \begin{tabular}{|l|l|l|l|l|l|}\hline \texttt{relationship} & $R$ & $C_1$
    & $C_2$ & \dots & $C_n$ \\ \hline
  \end{tabular} \hfill ($n \ge 2$)
\end{itemize}
where $R$ is an object property and each $C_i$ is a class, for $1 \le
i \le n$.  For every class $C_i$, the property block induces the DL
axiom \[C_i \sqsubseteq \exists R . C_{i+1} \] stating that each
instance of $C_i$ has, amongst possibly other things, a relationship
through $R$ to some instance of $C_{i+1}$.  The following example
\begin{tabbing}
   ~~need example here
\end{tabbing}

\mypara{Transitive Block} 

\mypara{}Transitive blocks state that a property is transitive. That
is, if $P$ is transitive and a concept instance $O_1$ is related to an
instance $O_2$ by $P$, and $O_2$ is related to an instance $O_3$ by
$P$, then $O_1$ is also by definition related to $O_3$ by $P$. A
transitive block has the form
\begin{itemize}
\item[]
  \begin{tabular}{|l|l|l|l|l|l|}\hline \texttt{transitive} & $R$ & $C_1$
    & $C_2$ & \dots & $C_n$ \\ \hline
  \end{tabular} \hfill ($n \ge 2$)
\end{itemize}
where $P$ is an object property. For example, the block
\begin{quote}\texttt{transitive} \texttt{hasPart} \texttt{Body}
  \texttt{Head} \texttt{Eye} \texttt{Retina}
\end{quote} states that a body has at least one head, a head has at
least one eye, and an eye has at least one retina.




\paragraph{Attribute Block.} Attribute blocks are used to define the
required \emph{datatype} properties of concepts. An attribute block
has the form
\begin{itemize}
\item[]
  \begin{tabular}{|l|l|l|l|l|l|l|}\hline \texttt{attribute} & $P$ & $D$ & $C_1$
    & $C_2$ & \dots & $C_n$ \\ \hline
  \end{tabular} \hfill ($n \ge 1$)
\end{itemize}
where $P$ is a datatype property, each $C_i$ is a concept for $1 \le i
\le n$, and $D$ is a datatype (\texttt{anyValueType}, \texttt{string},
\texttt{int}, etc.). For every concept $C_i$, the property block
induces the DL axiom \[C_i \sqsubseteq (\exists P . D)\] stating that
each instance of $C_i$ has, amongst possibly other things, a
relationship through $P$ to a data value of type $D$.


\paragraph{Value Block.} Value blocks define required datatype
property \emph{constant values} for concepts. A value block has the
form
\begin{itemize}
\item[]
  \begin{tabular}{|l|l|l|l|l|l|l|}\hline \texttt{value} & $P$ & $V$ & $C_1$
    & $C_2$ & \dots & $C_n$ \\ \hline
  \end{tabular} \hfill ($n \ge 1$)
\end{itemize}
where $P$ is a datatype property, $C_i$ is a concept for $1 \le i \le
n$, and $V$ is a datatype value. For each concept $C_i$, the value
block induces the DL axiom \[C_i \sqsubseteq (V \in P)\] stating that
each instance of $C_i$ has a value $V$ for property $P$.  The value
restrictions stated by value blocks are often used for defining
so-called \emph{value partitions} \cite{co-ode}.

\paragraph{Inverse Block.} Inverse blocks state that two object
properties are inverses of each other. That is, for inverse properties
$P_1$ and $P_2$ and concept instances $O_1$ and $O_2$, if $P_1(O_1) =
O_2$, then $P_2(O_2) = O_1$.  An inverse block has the form
\begin{itemize}
\item[]
  \begin{tabular}{|l|l|l|}\hline \texttt{inverse} & $P_1$ & $P_2$
\\ \hline
  \end{tabular}
\end{itemize}
where $P_1$ and $P_2$ are object properties. 

\paragraph{Minimum Block.} Minimum blocks state the minimum
number of properties $P$ an instance of a concept may have.
Minimum blocks have the form
\begin{itemize}
\item[]
  \begin{tabular}{|l|l|l|l|l|l|l|}\hline \texttt{minimum} & $P$ & $N$ & 
    $C_1$ & $C_2$ & $\dots$ & $C_m$
    \\ \hline
  \end{tabular}
\end{itemize}
where $N$ is the minimum number of properties $P$ that instances of
concept $C_1$ may have to instances of concept $C_2$, $C_2$ to $C_3$,
and so on. A cardinality block induces the DL axiom \[C_i \sqsubseteq
(\le N P.C_{i+1})\] stating that each instance of $C_i$ must be related to
at least $N$ unique instances of $C_{i+1}$ via $P$. For example, the blocks
\begin{quote}
\texttt{minimum} \texttt{hasPart} 1 \texttt{Body} \texttt{Head} \\
\texttt{minimum} \texttt{hasPart} 2 \texttt{Head} \texttt{Eye}
\end{quote}
states that a body has at least one head and at least two eyes.

\paragraph{Maximum Block.} Maximum blocks state the maximum
number of properties $P$ an instance of a concept may have.
Maximum blocks have the form
\begin{itemize}
\item[]
  \begin{tabular}{|l|l|l|l|l|l|l|}\hline \texttt{maximum} & $P$ & $N$ & 
    $C_1$ & $C_2$ & $\dots$ & $C_m$
    \\ \hline
  \end{tabular}
\end{itemize}
where $N$ is the maximum number of properties $P$ that instances of
concept $C_1$ may have to instances of concept $C_2$, $C_2$ to $C_3$,
and so on. A cardinality block induces the DL axiom \[C_i \sqsubseteq
(\ge N P.C_{i+1})\] stating that each instance of $C_i$ may be related to
at most $N$ unique instances of $C_{i+1}$ via $P$. For example, the blocks
\begin{quote}
\texttt{maximum} \texttt{hasPart} 1 \texttt{Body} \texttt{Head} \\
\texttt{maximum} \texttt{hasPart} 2 \texttt{Head} \texttt{Eye}
\end{quote}
states that a body has at least one head and at least two eyes.


\paragraph{Sufficient Block.} Sufficient blocks state that any
instance having a property $P$ to an instance of a concept $C_2$ is a
sufficient condition for being an instance of a concept $C_1$. A
sufficient block has the form
\begin{itemize}
\item[]
  \begin{tabular}{|l|l|l|l|}\hline \texttt{sufficient} & $C_1$ & $P$ & $C_2$
    \\ \hline
  \end{tabular}
\end{itemize}
where $C_1$ is the target concept (i.e., denoting the concept
definition), $P$ is the sufficient property, and $C_2$ is the
sufficient concept. A sufficient block induces the DL axiom \[C_1
\equiv \exists P.C_2\] Sufficient blocks provide a mechansism to
construct simple class definitions (i.e., classes defined precisely by
other classes), primarily for use with value partitions. [NOTE: these
should be anded together?]

\paragraph{Description Block.} Description blocks assign plain-text
definitions to concepts and properties. A description block has the
form
\begin{itemize}
\item[]
  \begin{tabular}{|l|l|l|}\hline \texttt{description} & $T$ & $S$
\\ \hline
  \end{tabular}
\end{itemize}
where $T$ is either a property or a concept and $S$ is a description
string.

\paragraph{Note Block.} Note blocks add comments to the current
ontology, and are ignored by \owlifier.  A note block has the form
\begin{itemize}
\item[]
  \begin{tabular}{|l|l|l|}\hline \texttt{note} & $S$
\\ \hline
  \end{tabular}
\end{itemize}
where $S$ is a comment string.

*** Say something about relaxing block syntax ... to make it easier to
specify ontologies. Also, allow blocks to be given in any order.


\section{\owlifier\ Properties and Reasoning}
\label{sec:properties}


Some desirable properties: 
\begin{itemize}
\item non-ambiguous (no block leads to ambiguous DL axioms)
\item ``reasonable'' (not everything has to be explicitly stated)
\item ???
\end{itemize}

\section{\owlifier\ Implementation}
\label{sec:implementation}

Flags: 
\begin{itemize}
\item delimeter characters 
\item perform classification
\item warnings
\item owlifier to owl and owl to owlifier
\item ??? 
\end{itemize}


\section{Conclusion}
\label{sec:conclusion}



%\bibliographystyle{elsarticle-num}
\bibliographystyle{abbrv}
\bibliography{main}


\end{document}

