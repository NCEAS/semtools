\documentclass[preprint,number]{elsarticle} 
% other options: preprint, review, 1p, 3p, 5p, 
% bib options: authoryear, number, longtitle,
% other options: times


\newcommand{\Owlifier}{\textsf{Owlifier}}
\newcommand{\owlifier}{\textsf{owlifier}}

\newcommand{\myblock}[1]{\vspace{12pt}\noindent\textbf{#1}}

\newcommand{\secref}[1]{Section~\ref{#1}}
\newcommand{\figref}[1]{Figure~\ref{#1}}

\title{Owlifier: Creating OWL-DL Ontologies from Simple
  Spreadsheet-Based Knowledge Descriptions\tnoteref{t1}}
%\tnotetext[t1]{This work supported in part by NSF grants ...}

\author[smb]{Shawn Bowers\corref{cor1}}
\ead{sbowers@ucdavis.edu}

\author[jsm]{Joshua S. Madin}
\ead{jmadin@bio.mq.edu.au}

\author[mps]{Mark P. Schildhauer}
\ead[url]{schild@nceas.ucsb.edu}

\cortext[cor1]{Corresponding author}

\address[smb]{UC Davis Genome Center}

\address[jsm]{Dept. of Biological Sciences, Macquarie University, Australia}

\address[mps]{National Center for Ecological Analysis and Synthesis,
  UC Santa Barbara}



\begin{document}

\begin{abstract}
  Discovery and integration of data is important in many ecological
  studies, especially those that concern broad-scale ecological
  questions. Discovery and integration is often a difficult and
  time-consuming task for researchers, in part because informal,
  ambiguous, and sometimes inconsistent terms are used to describe
  data semantics.  Ontologies can help address this problem by
  providing a means to define ecological concepts to more consistently
  annotate, relate, and search for data sets.  However, unlike in
  molecular biology or biomedicine, few ontology development efforts
  exist within ecology. Ontology development often requires
  considerable expertise in ontology languages and development tools,
  which is often a barrier for ontology creation in ecology. In this
  paper we address this problem by providing an approach for ontology
  creation that allows ecologists to use common spreadsheet tools to
  describe different aspects of an ontology.  We present conventions
  for creating, relating, and constraining concepts through
  spreadsheets, and provide software tools for converting these
  ontologies into equivalent OWL-DL representations. We also consider
  inverse translations, i.e., to convert ontologies represented using
  OWL-DL into our spreadsheet format. Our approach allows large lists
  of terms to be easily related and organized into concept
  hierarchies, and generally provides a more intuitive and natural
  interface for ontology development by ecologists.
\end{abstract}

\maketitle

\section{Introduction}

Within the fields of molecular biology and biomedicine considerable
effort has gone into developing ontologies for improving data
discovery and integration
\cite{bard04:_ontol_in_biolog,ashburner00:_gene_ontol}. While similar
benefits can be obtained for ecological data, far fewer efforts exist
to develop richer and more consistent terminologies of ecology
concepts
\cite{madin08:_advan_ecolog_resear_with_ontol,parr20:_data_sharin_in_ecolog_and_evolut}.
The use of formal ontologies can significantly enhance metadata
descriptions of ecological data. Annotating data with ontology terms
can both help users interpret data as well as enable advanced
capabilities for data discovery and integration, e.g., by exploiting
subsumption and part-of hierarchies as well as more formal constraints
such as cardinality restrictions on properties and term equivalence.

Efforts to engage scientists in the development of ontologies
typically leverage the W3C Web Ontology Language (OWL)
\cite{smith04:_owl_web_ontol_languag_guide} as a standard XML syntax
for representing and sharing ontologies. A key advantage of OWL is
that it is supported by a wide range of generic tools, including
editors
\cite{knublauch04:_editin_descr_logic_ontol_with,kalyanpur05:_swoop},
reasoning systems
\cite{sirin07:_pellet,tsarkov06:_fact_descr_logic_reason}, query
languages
\cite{prudhommeaux08:_sparq_query_languag_for_rdf,motik05:_query_answer_for_owl_dl_with_rules},
and storage technologies
\cite{carroll04:_jena,broekstra02:_sesam}. Most of these tools,
however, are primarily targeted at experts in knowledge engineering
and software development familiar with the underlying description
logic semantics of OWL-DL \cite{grau08:_owl}. This is especially true
with ontology editors (such as Protege, SWOOP, etc.), which allow for
very detailed ontology specifications, but at the same time require
considerable understanding of the underlying ontology formalisms and
syntax. Thus, we see the lack of suitable ontology editing tools for
scientists as one of the major barriers for more wide-scale adoption
of ontologies in ecology.


This paper presents a novel approach for ontology creation that aims
at being more intuitive for ecologists and that can be used to rapidly
construct large ontologies for describing scientific data. Our
approach is to allow scientists to use common spreadsheet-based tools
to describe, in an intuitive way, different aspects of an ontology,
and then to take these descriptions and convert them into full-fledged
OWL ontologies using a software application called \owlifier. An
\owlifier\ spreadsheet consists of a set of \emph{blocks} that have a
predefined template structure for users to fill in. Each non-empty row
in an \owlifier\ table constitutes a block. Each block defines
different aspects of an ontology including ontology classes,
subclasses, synonyms, and properties.  We also provide blocks for
plain-text descriptions of classes and properties, and for referencing
one or more existing ontologies (e.g., to extend an existing ontology
or to define ontology articulations). Blocks can be sparse (inheriting
from previous blocks), which can further simplify the creation of
large ontologies.

While not as expressive as OWL-DL, our approach can produce ontology
structures essential for enhanced data discovery and integration
\cite{madin07:_ontol_for_descr_and_synth}, while at the same time
provide a more accessible user interface for ecologists. Further, our
approach can be used to rapidly construct class hierarchies from long
lists of keywords using familiar spreadsheet software. For instance,
an ecologist can easily list (or import) a set of terms, and then
incrementally organize these into class hierarchies, and define
relevant properties and their constraints. Based on our experiences
using \owlifier\ with ecologists and evolutionary biologists studying
trait data, we found that this approach can enable them to quickly and
easily comprehend and construct useful ontologies.

The rest of this paper is organized as follows. In
\secref{sec:owlifier} we describe the basic syntax and semantics of
\owlifier. We define blocks that support a large subset of OWL-DL and
that also generally follow the ontology creation guidelines defined in
\cite{rector04:_owl_pizzas}. We also simplify certain aspects of
ontology creation using OWL-DL, e.g., by assuming classes are disjoint
by default (unless specified otherwise) and by applying implicit
property restriction closures \cite{rector04:_owl_pizzas}. In
\secref{sec:characteristics} we describe additional characteristics of
\owlifier\ and discuss issues with respect to classification and
reasoning. In \secref{sec:implementation} we briefly describe the
\owlifier\ implementation, and conlcude in \secref{sec:conclusion}
with related and future work. In general, the goal of \owlifier\ is
not to support all constructs in OWL-DL, but instead to provide a
higher-level ontology syntax (via spreadsheet blocks) that is easy for
ecologists to use and understand while also providing the necessary
constructs for developing typical ecological ontologies. By compiling
\owlifier\ to OWL-DL, we also allow for experts to refine and extend
the ontology using more advanced ontology editing tools if necessary.



\section{The Syntax and Semantics of \Owlifier}
\label{sec:owlifier}

An \owlifier\ table defines an OWL-DL
\cite{smith04:_owl_web_ontol_languag_guide} ontology through a set of
\emph{blocks} representing one or more ontology definitions.  Each
non-empty row in an \owlifier\ table corresponds to a block. The type
of the block is given in the first column of the row. We describe each
type of block supported by \owlifier\ below. Here we assume that if
any properties or classes used in a block are not imported from
another ontology, then they are to be added to the ontology being
specified by the \owlifier\ table. In general, we name blocks
according to the more generic terms used in
\cite{bowers08:_concep_model_framew_for_expres,madin07:_ontol_for_descr_and_synth}
instead of those of OWL-DL. This allows \owlifier\ to generate
ontologies that extend the observational model of
\cite{bowers08:_concep_model_framew_for_expres,madin07:_ontol_for_descr_and_synth}
for data annotation, and in certain cases avoids confusion with
established terms commonly used within ecology.

\myblock{Import Blocks.} Import blocks assign namespace labels to
external ontologies. Each external ontology is imported into the
current ontology. We refer to the ontologies of import blocks as
\emph{imported ontologies}.  Using import blocks, classes and
properties of imported ontologies can be used within other blocks of
an \owlifier\ table.  Rows containing import blocks take the form
\begin{itemize}
\item[]
  \begin{tabular}{|l|l|l|}\hline
    \textsf{import} & $n$ & $u$ \\ \hline 
  \end{tabular} 
\end{itemize}
where $n$ is a namespace label and $u$ is an OWL ontology URI. Classes
and properties from imported ontologies are referenced by prefixing
the namespace label $n$ to the corresponding class or property name in
the normal way. As an example, the following block imports the SWEET
``Earth Realm'' ontology \cite{raskin:_seman_web_for_earth_and}
\begin{tabbing}
  ~~\textsf{import}  \textsf{sweet} 
  \textsf{http://sweet.jpl.nasa.gov/ontology/earthrealm.owl}
\end{tabbing}
With this import block the class denoting Marine Ecosystems (a class
defined in the SWEET ontology) can be referred to from within an
\owlifier\ table using the expression
\textsf{sweet:MarineEcosystem}. Because this class refers to a class
in another ontology, we refer to it as an \emph{imported class}.


\myblock{Entity Blocks.} Entity blocks are the primary blocks used to
define ontologies. An entity block introduces new OWL classes and
specifies subclass relationships. Imported classes may also be used
within entity blocks by prefixing class names with namespace labels
(as described above).  Rows containing entity blocks take the form
\begin{itemize}
\item[] 
  \begin{tabular}{|l|l|l|l|l|}\hline
    \textsf{entity} & $c_1$ & $c_2$ & \dots & $c_n$ \\ \hline 
  \end{tabular} \hfill ($n \ge 1$)
\end{itemize}
where each class $c_i$ is asserted in the current ontology to subsume
$c_{i+1}$, for $1 \le i < n$. That is, each $c_i$ in an entity block
induces the description logic axiom $c_{i+1} \sqsubseteq c_i$.  If
both $c_i$ and $c_{i+1}$ are imported classes, we say that the block
defines an ``articulation'' (i.e., mapping) between the two
classes. The following entity block defines a simple subclass
hierarchy.
\begin{tabbing}
  ~~\textsf{entity} \textsf{PhysicalFeature} 
    \textsf{AquaticPhysicalFeature} \textsf{River}
\end{tabbing}
This block states that Physical Feature, Aquatic Physical Feature, and
River are classes; River is a subclass of Aquatic Physical Feature;
and Aquatic Physical Feature is a subclass of Physical Feature. The
following entity block introduces a new class via an imported class.
\begin{tabbing}
  ~~\textsf{entity} \textsf{sweet:MarineEcosystem} 
    \textsf{IntertidalEcosystem}
\end{tabbing}
This block states that Intertidal Ecosystem is a subclass of the
Marine Ecosystem class imported from the SWEET ontology. Similarly,
assuming ``marine'' denotes an existing ontology of marine ecosystem
concepts, the following entity block defines a simple class
articulation.
\begin{tabbing}
  ~~\textsf{entity} \textsf{sweet:MarineEcosystem} 
    \textsf{marine:DeapSeaEcosystem}
\end{tabbing}
This block states that the Deap Sea Ecosystem class of the marine
ontology is a subclass of the Marine Ecosystem class of the SWEET
ontology.

\myblock{Synonym Blocks.} Synonym blocks define equivalence
relationships between ontology classes.  Rows containing synonym
blocks take the form
\begin{itemize}
\item[] 
  \begin{tabular}{|l|l|l|l|l|}\hline
    \textsf{synonym} & $c_1$ & $c_2$ & \dots & $c_n$ \\ \hline 
  \end{tabular} \hfill ($n \ge 2$)
\end{itemize}
where each class $c_i$ is equivalent to class $c_{i+1}$ in the current
ontology, for $1 \le i < n$. That is, each $c_i$ in a synonym blocks
induces a description logic axiom of the form $c_i \equiv
c_{i+1}$. The following synonym block defines a simple equivalence
relationship.
\begin{tabbing}
  ~~\textsf{synonym} \textsf{Maize} \textsf{Corn}
\end{tabbing}
This block states that the Maize and Corn classes are synonyms, i.e.,
equivalent classes. Similar to entity blocks, synonym blocks often
contain imported classes, e.g., to extend an existing ontology or to
define ontology articulations.


\myblock{Overlap Blocks.} Except in certain situations (described
further in \secref{sec:characteristics}), classes are generally
assumed to be disjoint in \owlifier.  Overlap blocks explicitly relax
this assumption by stating that a give set of classes may have
overlapping instances. Rows containing overlap blocks take the form
\begin{itemize}
\item[] 
  \begin{tabular}{|l|l|l|l|l|}\hline
    \textsf{overlap} & $c_1$ & $c_2$ & \dots & $c_n$ \\ \hline 
  \end{tabular} \hfill ($n \ge 2$)
\end{itemize}
where each class $c_i$ is allowed to share instances with each class
$c_j$, for $1 \le i,j \le n$. In particular, a given $c_i$ and $c_j$
in an overlap block are not defined to be disjoint classes in the
current ontology. As an example, consider the following entity blocks
that define the classes Estuary, Lagoon, and Marsh as subclasses of
Ecological Habitats.
\begin{tabbing}
  ~~\textsf{entity} \textsf{EcologicalHabitat} \textsf{Estuary} \\ 
  ~~\textsf{entity} \textsf{EcologicalHabitat} \textsf{Lagoon} \\ 
  ~~\textsf{entity} \textsf{EcologicalHabitat} \textsf{Marsh} 
\end{tabbing}
Given only these blocks, \owlifier\ treats Estuary, Lagoon, and Marsh
as disjoint classes. To relax this assumption and allow, e.g., types
of Lagoons to also be types of Estuaries, we explicitly add the
following overlap block
\begin{tabbing}
  ~~\textsf{overlap} \textsf{Estuary} \textsf{Lagoon}
\end{tabbing}
In general, overlap blocks are rarely used but provide a mechanism to
override the default behavior of \owlifier\ in asserting disjoint
classes.

% \myblock{Property Blocks.} Property blocks define basic object property
% domain and range constraints. , where the domain of an
% object property denotes the set of individuals that can have the
% property, and the range denotes the set of individuals that can be
% related to domain individuals through the property. Rows containing
% relationship blocks take the form 
% \begin{itemize}
% \item[]
%   \begin{tabular}{|l|l|l|l|}\hline \textsf{property} & $p$ & $c_1$
%     & $c_2$ \\ \hline
%   \end{tabular} \hfill ($n \ge 2$)
% \end{itemize}
% where $p$ is the object property, class $c_1$ is the property domain,
% and class $c_2$ is the property range. 

\myblock{Relationship Blocks.} Relationship blocks define
\emph{required} object properties of classes.  An object property
within OWL is a property defined between two class instances. Rows
containing relationship blocks take the form
\begin{itemize}
\item[]
  \begin{tabular}{|l|l|l|l|l|l|}\hline \textsf{relationship} & $p$ & $c_1$
    & $c_2$ & \dots & $c_n$ \\ \hline
  \end{tabular} \hfill ($n \ge 2$)
\end{itemize}
where $p$ is an object property and each $c$ is a class.  For every
class $c_i$, the relationship block induces the DL axiom $c_i
\sqsubseteq \exists p . c_{i+1}$ stating that each instance of $c_i$
is $p$-related to some instance of $c_{i+1}$, for $1 \le i < n$.  For
example, the following block states that instances of the class
California Voles live in Grassy Areas.
\begin{tabbing}
  ~~\textsf{relationship} \textsf{livesIn} \textsf{CaliforniaVole} 
    \textsf{GrassyArea}
\end{tabbing}
In some cases, a particular property can apply to a sequence of
classes, and for convenience, each such class can be specified in a
single block. For example, consider the following block.
\begin{tabbing}
  ~~\textsf{relationship} \textsf{directlyBelow} \textsf{Hypolimnion} 
    \textsf{Thermocline} \textsf{Epilimnion} 
\end{tabbing}
This block states that, e.g., within a thermally stratified lake, the
Hypolimnion layer is directly below the Thermocline layer, and the
Thermocline layer is directly below the Epilimnion layer. 

\myblock{Transitive Blocks.} Transitive blocks are special cases of
relationship blocks where the object property is asserted to be
transitive. If a property $p$ is declared to be transitive, whenever
$p$ relates an individual $o_1$ to an individual $o_2$, and an
individual $o_2$ to an individual $o_3$, then $p$ is also assumed to
relate $o_1$ to $o_3$. Rows containing transitive blocks take the form
\begin{itemize}
\item[]
  \begin{tabular}{|l|l|l|l|l|l|}\hline \textsf{transitive} & $p$ & $c_1$
    & $c_2$ & \dots & $c_n$ \\ \hline
  \end{tabular} \hfill ($n \ge 2$)
\end{itemize}
where $p$ is an object property and each $c$ is a class.  The
following block is a simple example of a transitive relationship.
\begin{tabbing}
  ~~\textsf{transitive} \textsf{hasPart} \textsf{Body}
  \textsf{Head} \textsf{Eye} \textsf{Retina}
\end{tabbing} 
This block states that every instance of the class Body has a Head as
a part, every instance of the class Head has an Eye as a part, and
every instance of the class Eye has a Retina as a part. Moreover,
because the \textsf{hasPart} property above is defined to be
transitive, it is possible to infer that every instance of Body also
has an Eye and a Retina as a part through the implied relationship
restrictions $\textsf{Body} \sqsubseteq \exists \textsf{hasPart}
. \textsf{Head}$, $\textsf{Head} \sqsubseteq \exists \textsf{hasPart}
. \textsf{Eye}$, and $\textsf{Eye} \sqsubseteq \exists
\textsf{hasPart} . \textsf{Retina}$.


\myblock{Cardinality Blocks.} Cardinality blocks are also similar to
relationship blocks.  We consider three types of cardinality blocks
for defining minimum, maximum, and exact cardinality restrictions. A
minimum block states the smallest number of properties $p$ to distinct
individuals that an individual of a class may have.  Rows containing
minimum blocks take the form
\begin{itemize}
\item[]
  \begin{tabular}{|l|l|l|l|l|l|l|}\hline \textsf{min} & $p$ & $m$ & 
    $c_1$ & $c_2$ & $\dots$ & $c_n$
    \\ \hline 
  \end{tabular} \hfill $(n \ge 2)$
\end{itemize}
where $m$ is the minimum number of properties $p$ that instances of
class $c_i$ must have to instances of concept $c_{i+1}$, for $1 \le i
< n$.  For each class $c_i$, a minimum cardinality block induces the
description logic axiom $c_{i} \sqsubseteq \; (\le m) \; p.c_{i+1}$
stating that each instance of $c_i$ must be $p$-related to at least
$m$ unique instances of $c_{i+1}$. The following two blocks
demonstrate simple minimum cardinality constraints.
\begin{tabbing}
  ~~\textsf{min} \textsf{hasPart} 1 \textsf{Body} \textsf{Head} 
  \textsf{Nose} \\
  ~~\textsf{min} \textsf{hasPart} 2 \textsf{Head} \textsf{Eye}
\end{tabbing}
The first block states that instances of the class Body have at least
one Head as a part, which in turn have at least one Nose as a
part.\footnote{Cardinality restrictions ensuring participation to at
  least one property are typically not given through minimum
  cardinality blocks since they are also implied by relationship
  blocks.} The second block states that instances of the class Head
have at least two Eyes as parts. 

A maximum block states the largest number of properties $p$ to
distinct individuals that an individual of a class may have.  Rows
containing maximum blocks take the form
\begin{itemize}
\item[]
  \begin{tabular}{|l|l|l|l|l|l|l|}\hline \textsf{max} & $p$ & $m$ & 
    $c_1$ & $c_2$ & $\dots$ & $c_n$
    \\ \hline
  \end{tabular} \hfill $(n \ge 2)$
\end{itemize}
where $m$ is the maximum number of properties $p$ that instances of
concept $c_i$ may have to instances of concept $c_{i+1}$, for $1 \le i
< n$.  For each class $c_i$, a maximum cardinality block induces the
description logic axiom $c_i \sqsubseteq \; (\ge m) \; p.c_{i+1}$
stating that each instance of $c_i$ may be $p$-related to at most $m$
unique instances of $c_{i+1}$. The following two blocks demonstrate
simple maximum cardinality constraints.
\begin{tabbing}
  ~~\textsf{max} \textsf{hasPart} 1 \textsf{Body} \textsf{Head} 
  \textsf{Nose} \\
  ~~\textsf{max} \textsf{hasPart} 2 \textsf{Head} \textsf{Eye}
\end{tabbing}
The first block states that instances of the class Body have at most
one Head as a part, which in turn has at most one Nose as a part. The
second block states that instances of the class Head have at most two
Eyes as parts. 

An exact block ensures both a minimum and maximum number $m$ of
properties $p$ to distinct individuals that an individual of a class
must have. Rows containing exact blocks take the form
\begin{itemize}
\item[]
  \begin{tabular}{|l|l|l|l|l|l|l|}\hline \textsf{exact} & $p$ & $m$ & 
    $c_1$ & $c_2$ & $\dots$ & $c_n$
    \\ \hline
  \end{tabular} \hfill $(n \ge 2)$
\end{itemize}
where $m$ is the number of properties $p$ that instances of concept
$c_i$ must have to instances of concept $c_{i+1}$, for $1 \le i < n$.
For each class $c_i$, an exactly block induces the description logic
axiom $c_i \sqsubseteq \; (= m) \; p.c_{i+1}$ stating that each
instance of $c_i$ must be $p$-related to at $m$ unique instances of
$c_{i+1}$.

\myblock{Inverse Blocks.} Inverse blocks state that two object
properties are inverses of each other. If $p_1$ and $p_2$ are defined
to be inverse properties, whenever $p_1$ relates an individual $o_1$
to an individual $o_2$ then $p_2$ (as the inverse of $p_1$) is assumed
to relate $o_2$ to $o_1$.  Rows containing inverse blocks take the
form
\begin{itemize}
\item[]
  \begin{tabular}{|l|l|l|}\hline \textsf{inverse} & $p_1$ & $p_2$
\\ \hline
  \end{tabular}
\end{itemize}
where $p_1$ and $p_2$ are object properties. A common example of
inverse properties are \texttt{hasPart} and \texttt{partOf}, i.e., if
an individual $o_1$ has an individual $o_2$ as a part, then $o_2$ is
by definition a part of $o_1$.


% \myblock{Attribute Blocks.} Attribute blocks define required
% \emph{datatype} properties of classes. Unlike object properties, a
% datatype property within OWL is a property defined between a class
% instance and a literal value (e.g., a string or integer). Rows
% containing attribute blocks take the form
% \begin{itemize}
% \item[]
%   \begin{tabular}{|l|l|l|l|l|l|l|}\hline \textsf{attribute} & $p$ & $c_1$
%     & $c_2$ & \dots & $c_n$ \\ \hline
%   \end{tabular} \hfill ($n \ge 1$)
% \end{itemize}
% where $p$ is a datatype property and $c_i$ is a class, for $1 \le i
% \le n$. For each concept $c_i$, the attribute block induces the
% description logic axiom $c_i \sqsubseteq \exists p$ stating that
% each instance of $c_i$ has, amongst possibly other things, a
% property $p$ with a literal value. Attributes are often useful for
% As an example, the following ...


% \myblock{Value Blocks.} Value blocks define required datatype property
% \emph{constant values} for concepts. A value block has the form
% \begin{itemize}
% \item[]
%   \begin{tabular}{|l|l|l|l|l|l|l|}\hline \textsf{value} & $P$ & $V$ & $C_1$
%     & $C_2$ & \dots & $C_n$ \\ \hline
%   \end{tabular} \hfill ($n \ge 1$)
% \end{itemize}
% where $P$ is a datatype property, $C_i$ is a concept for $1 \le i \le
% n$, and $V$ is a datatype value. For each concept $C_i$, the value
% block induces the DL axiom \[C_i \sqsubseteq (V \in P)\] stating that
% each instance of $C_i$ has a value $V$ for property $P$.  The value
% restrictions stated by value blocks are often used for defining
% so-called \emph{value partitions} \cite{co-ode}.


\myblock{Sufficient Blocks.} Sufficient blocks are similar to synonym
blocks in that they state equivalences between classes. However,
equivalence relationships are defined in sufficient blocks through
property restrictions (i.e., via anonymous classes). We consider two
main types of sufficient blocks. Rows containing sufficient blocks
take one of the following forms.
\begin{itemize}
\item[]
  \begin{tabular}{|l|l|l|l|l|l|}\hline 
    \textsf{sufficient} & \textsf{min}, \textsf{max}, or 
    \textsf{exact} & $m$ & $c_1$ & $p$ & $c_2$\\ \hline
  \end{tabular}
\item[]
  \begin{tabular}{|l|l|l|l|l|}\hline 
    \textsf{sufficient} & \textsf{only} & $c_1$ & $p$ & \{\textsf{not}\} $c_2$\\ \hline
  \end{tabular}
\end{itemize}
The first form states that individuals that are $p$-related to at
least, at most, or exactly $m$ individuals of class $c_2$ are by
definition individuals of the class $c_1$. Sufficient blocks of this
form induce either the description logic axiom $c_1 \equiv \; (\le m)
\; p . c_2$, $c_1 \equiv \; (\ge m) \; p . c_2$, or $c_1 \equiv \; (=
m) \; p . c_2$ depending on whether the qualifier \textsf{min},
\textsf{max}, or \textsf{exact} is used, respectively. The second form
states that individuals that are $p$-related to only individuals of
class $c_2$ are by definition individuals of the class
$c_1$. Sufficient blocks of this form induce description logic axioms
$c_1 \equiv \forall p . c_2$. The complement of $c_2$ may also be used
within these blocks via the expression \textsf{not $c_2$}. Sufficient
blocks of this form induce description logic axioms $c_1 \equiv
\forall p . \neg c_2$ stating that individuals that are $p$-related to
only individual that are not of class $c_2$ (i.e., the complement of
$c_2$) are by definition individuals of class $c_1$.  Multiple
sufficient blocks for a class $c_1$ are treated as a single
description logic axiom, e.g., if each of the above blocks are defined
for $c_1$ we have $c_1 \equiv \; (\le m \; p .  c_2) \sqcap (\ge m \;
p . c_2) \sqcap (\forall p.c_2)$. The following blocks are simple
examples of sufficient conditions.
\begin{tabbing}
  ~~\textsf{sufficient} \textsf{mimimum} 1 \textsf{MammalProper} 
  \textsf{hasPart} \textsf{MammalProperEar}
  ~~\textsf{sufficient} \textsf{maximum} 2 \textsf{MammalProper} 
  \textsf{hasPart} \textsf{MammalProperEar}
  ~~\textsf{sufficient} \textsf{mimimum} 1 \textsf{MammalProper} 
  \textsf{hasPart} \textsf{Hair}

  ~~\textsf{sufficient} \textsf{mimimum} 3 \textsf{MammalProper} 
  \textsf{hasPart} \textsf{MiddleEarBone}
\end{tabbing}


\begin{tabbing}
  ~~\textsf{sufficient} \textsf{relationship} \textsf{MammalProper} \textsf{hasPart} \textsf{SweatGland} \\
  ~~\textsf{sufficient} \textsf{MammalProper} \textsf{hasPart} \textsf{Hair}
\end{tabbing}
These blocks state that 



\myblock{Description Blocks.} Description blocks assign plain-text
definitions to concepts and properties. A description block has the
form
\begin{itemize}
\item[]
  \begin{tabular}{|l|l|l|}\hline \textsf{description} & $T$ & $S$
    \\ \hline
  \end{tabular}
\end{itemize}
where $T$ is either a property or a concept and $S$ is a description
string.


\myblock{Note Blocks.} Note blocks add comments to the current
ontology, and are ignored by \owlifier.  A note block has the form
\begin{itemize}
\item[]
  \begin{tabular}{|l|l|l|}\hline \textsf{note} & $S$
\\ \hline
  \end{tabular}
\end{itemize}
where $S$ is a comment string.



\section{Additional Characteristics of \Owlifier}
\label{sec:characteristics}


Some desirable properties: 
\begin{itemize}
\item non-ambiguous (no block leads to ambiguous DL axioms)
\item ``reasonable'' (not everything has to be explicitly stated)
\item ???
\end{itemize}

*** Using owlifier to represent values, value types, and untangling
from owl-pizzas ***


*** Say something about relaxing block syntax ... to make it easier to
specify ontologies. Also, allow blocks to be given in any order.

\section{Implementation of \Owlifier}
\label{sec:implementation}

Flags: 
\begin{itemize}
\item delimeter characters 
\item perform classification
\item warnings
\item owlifier to owl and owl to owlifier
\item ??? 
\end{itemize}


\section{Conclusion}
\label{sec:conclusion}


related work: similar to dave's work on ``global taxonomic
constraints'', which assume certain structures of hierarchies, e.g.,
disjoint siblings. 

%\bibliographystyle{elsarticle-num}
\bibliographystyle{abbrv}
\bibliography{main}


\end{document}

