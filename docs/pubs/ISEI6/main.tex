\documentclass[preprint,number]{elsarticle} 
% other options: preprint, review, 1p, 3p, 5p, 
% bib options: authoryear, number, longtitle,
% other options: times


\newcommand{\owlifier}{Owlifier}
\newcommand{\mypara}[1]{\vspace{12pt}\noindent\textbf{#1}}

\title{Owlifier: Creating OWL-DL Ontologies from Simple
  Spreadsheet-Based Knowledge Descriptions\tnoteref{t1}}
%\tnotetext[t1]{This work supported in part by NSF grants ...}

\author[smb]{Shawn Bowers\corref{cor1}}
\ead{sbowers@ucdavis.edu}

\author[jsm]{Joshua S. Madin}
\ead{jmadin@bio.mq.edu.au}

\author[mps]{Mark P. Schildhauer}
\ead[url]{schild@nceas.ucsb.edu}

\cortext[cor1]{Corresponding author}

\address[smb]{UC Davis Genome Center}

\address[jsm]{Dept. of Biological Sciences, Macquarie University, Australia}

\address[mps]{National Center for Ecological Analysis and Synthesis,
  UC Santa Barbara}



\begin{document}

\begin{abstract}
abstract here...
\end{abstract}

\maketitle




\section{Introduction}


The use of formal ontologies can significantly enhance metadata
descriptions of ecological data by providing richer and more
consistent terminologies. Annotating data with ontology terms can both
help users interpret data as well as enable advanced capabilities for
data discovery and integration, e.g., by exploiting subsumption and
part-of hierarchies as well as more formal constraints such as
cardinality restrictions on properties and term equivalence. Many
efforts are underway to engage scientists in the development of
ontologies to represent common ecological and biodiversity
concepts. Most of these projects leverage OWL (the W3C Web Ontology
Language) as a standard XML syntax for representing and sharing
ontologies. A key advantage of OWL is that it is supported by a wide
range of generic tools, including editors, reasoning systems, query
languages, and storage technologies. These tools, however, are
primarily targeted at experts in knowledge engineering and software
development. This is especially true with ontology editors (such as
Prot?g?, OWLed, SWOOP, etc.), which allow for very detailed ontology
specifications, but at the same time require a considerable amount of
understanding of the underlying ontology formalisms and syntax. Thus,
we see the lack of suitable ontology editing tools for scientists as
one of the major barriers for more wide-scale adoption of ontologies
in ecology.

Here, we present a novel approach for ontology creation that aims at
being more intuitive for ecologists and that can be used to rapidly
construct large ontologies for describing scientific data. Our
approach is to allow scientists to use common spreadsheet tools to
describe, in an intuitive way, different aspects of an ontology, and
then to take these descriptions and convert them into full-fledged OWL
ontologies using a software application called owlifier. An owlifier
spreadsheet consists of a set of "blocks" that have a predefined
template structure for users to fill in. Each non-empty row in an
owlifier table constitutes a block, where blocks can be used to define
ontology concepts (including sub-concepts), concept synonyms,
overlapping concepts (i.e., that by definition are not disjoint),
properties (including their domain and range), and inverse
properties. We also provide blocks for plain-text descriptions of
concepts and properties, and for referencing one or more existing
ontologies (e.g., to extend an ontology or to define ontology
articulations). Blocks can be sparse (inheriting from previous
blocks), which simplifies the creation of large ontologies. Although
not as expressive as full-fledged OWL ontologies, our approach can
produce ontology structures essential for enhanced data discovery and
integration, while at the same time providing a more accessible user
interface for ecologists. Further, compared to many existing editors,
our approach can be used to rapidly construct concept hierarchies,
e.g., from long lists of keywords, within familiar spreadsheet
software. We have field-tested the owlifier approach with ecologists
and evolutionary biologists working with trait data, and found this
application enabled them to quickly and easily comprehend and
construct ontologies.



\section{\owlifier\ Syntax and Semantics}

An \owlifier\ table defines an OWL-DL
\cite{smith04:_owl_web_ontol_languag_guide} ontology through a set of
\emph{blocks} representing one or more ontology definitions.  Each
non-empty row in an \owlifier\ table corresponds to a block. The type
of the block is given in the first column of the row. We describe each
type of block supported by \owlifier\ below. Here we assume that if
any of the properties or concepts used in a block are defined, i.e.,
are not imported from another ontology, then they are added to the
ontology being defined by the \owlifier\ table.

\mypara{Import Block}  

\mypara{}Import blocks assign namespace labels to external
ontologies. Each external ontology is imported into the current
ontology. We refer to the ontologies of import blocks as
\emph{imported ontologies}.  Using import blocks, concepts and
properties of imported ontologies can be used within other blocks of
the table.  Import blocks take the form
\begin{itemize}
\item[]
  \begin{tabular}{|l|l|l|}\hline
    \texttt{import} & $\textit{N}$ & $\textit{U}$ \\ \hline 
  \end{tabular} 
\end{itemize}
where $\textit{N}$ is a namespace label and $\textit{U}$ is an OWL
ontology URI. Classes and properties from imported ontologies are
referenced by prefixing the namespace label $\textit{N}$ to the
corresponding class or property name in the normal way. The following
block imports the ``earth realm'' ontology from the set of SWEET
ontologies \cite{raskin:_seman_web_for_earth_and}.
\begin{tabbing}
  ~~\texttt{import sweet
    http://sweet.jpl.nasa.gov/ontology/earthrealm.owl}
\end{tabbing}
where the ontology class denoting marine ecosystems can be refered to
from within the corresponding \owlifier\ table using the syntax
\texttt{sweet:MarineEcosystem}. This class is referred to an an
``imported'' class.

\mypara{Class Block}  

\mypara{}Class blocks specify class and subclass relationships. Class
blocks take the form
\begin{itemize}
\item[] 
  \begin{tabular}{|l|l|l|l|l|}\hline
    \texttt{class} & $C_1$ & $C_2$ & \dots & $C_n$ \\ \hline 
  \end{tabular} \hfill ($n \ge 1$)
\end{itemize}
where each class $C_i$ is asserted in the current ontology to subsume
a class $C_{i+1}$, for $1 \le i < n$. Each $C_i$ in an entity block
induces a DL axiom \[C_i \sqsubseteq C_{i+1}.\] If both $C_i$ and
$C_{i+1}$ are imported classes, we say that the block defines an
``articulation'' (i.e., mapping) between them. The following class
block defines a simple subclass hierarchy
\begin{tabbing}
~~\texttt{class PhysicalFeature AquaticPhysicalFeature River}
\end{tabbing}
stating that a river is a subclass of aquatic physical features and
that aquatic physical features are a type of physical feature.

\mypara{Synonym Block}

\mypara{}Synonym blocks define an equivalence relationship between
classes.  A synonym block has the form
\begin{itemize}
\item[] 
  \begin{tabular}{|l|l|l|l|l|}\hline
    \texttt{synonym} & $C_1$ & $C_2$ & \dots & $C_n$ \\ \hline 
  \end{tabular} \hfill ($n \ge 2$)
\end{itemize}
where each class $C_i$ is asserted as being equivalent to class
$C_{i+1}$ in the current ontology, for $1 \le i < n$. For example, the
block
\begin{tabbing}
~~\texttt{synonym Maize Corn}
\end{tabbing}
defines maize and corn as synonym (i.e., equivalent) classes.


\mypara{Overlap Block} 

\mypara{}Except in certain situations (described further below),
classes are assumed to be disjoint.  Overlap blocks explicitly relax
this assumption for a given set of classes by stating that a set of
classes may have overlapping instances. An overlap block has the form
\begin{itemize}
\item[] 
  \begin{tabular}{|l|l|l|l|l|}\hline
    \texttt{overlap} & $C_1$ & $C_2$ & \dots & $C_n$ \\ \hline 
  \end{tabular} \hfill ($n \ge 2$)
\end{itemize}
where each class $C_i$ is allowed to share instances with each concept
$C_j$, for $1 \le i,j \le n$. In particular, $C_i$ and $C_j$ are not
defined to be disjoint classes in the current ontology. 

--- an example here ---


\mypara{Relationship Block}

\mypara{}Relationship blocks define required \emph{object} properties
of classes. A property block has the form
\begin{itemize}
\item[]
  \begin{tabular}{|l|l|l|l|l|l|}\hline \texttt{relationship} & $R$ & $C_1$
    & $C_2$ & \dots & $C_n$ \\ \hline
  \end{tabular} \hfill ($n \ge 2$)
\end{itemize}
where $R$ is an object property and each $C_i$ is a class, for $1 \le
i \le n$.  For every class $C_i$, the property block induces the DL
axiom \[C_i \sqsubseteq \exists R . C_{i+1} \] stating that each
instance of $C_i$ has, amongst possibly other things, a relationship
through $R$ to some instance of $C_{i+1}$.  The following example
\begin{tabbing}
   ~~need example here
\end{tabbing}

\mypara{Transitive Block} 

\mypara{}Transitive blocks state that a property is transitive. That
is, if $P$ is transitive and a concept instance $O_1$ is related to an
instance $O_2$ by $P$, and $O_2$ is related to an instance $O_3$ by
$P$, then $O_1$ is also by definition related to $O_3$ by $P$. A
transitive block has the form
\begin{itemize}
\item[]
  \begin{tabular}{|l|l|l|l|l|l|}\hline \texttt{transitive} & $R$ & $C_1$
    & $C_2$ & \dots & $C_n$ \\ \hline
  \end{tabular} \hfill ($n \ge 2$)
\end{itemize}
where $P$ is an object property. For example, the block
\begin{quote}\texttt{transitive} \texttt{hasPart} \texttt{Body}
  \texttt{Head} \texttt{Eye} \texttt{Retina}
\end{quote} states that a body has at least one head, a head has at
least one eye, and an eye has at least one retina.




\paragraph{Attribute Block.} Attribute blocks are used to define the
required \emph{datatype} properties of concepts. An attribute block
has the form
\begin{itemize}
\item[]
  \begin{tabular}{|l|l|l|l|l|l|l|}\hline \texttt{attribute} & $P$ & $D$ & $C_1$
    & $C_2$ & \dots & $C_n$ \\ \hline
  \end{tabular} \hfill ($n \ge 1$)
\end{itemize}
where $P$ is a datatype property, each $C_i$ is a concept for $1 \le i
\le n$, and $D$ is a datatype (\texttt{anyValueType}, \texttt{string},
\texttt{int}, etc.). For every concept $C_i$, the property block
induces the DL axiom \[C_i \sqsubseteq (\exists P . D)\] stating that
each instance of $C_i$ has, amongst possibly other things, a
relationship through $P$ to a data value of type $D$.


\paragraph{Value Block.} Value blocks define required datatype
property \emph{constant values} for concepts. A value block has the
form
\begin{itemize}
\item[]
  \begin{tabular}{|l|l|l|l|l|l|l|}\hline \texttt{value} & $P$ & $V$ & $C_1$
    & $C_2$ & \dots & $C_n$ \\ \hline
  \end{tabular} \hfill ($n \ge 1$)
\end{itemize}
where $P$ is a datatype property, $C_i$ is a concept for $1 \le i \le
n$, and $V$ is a datatype value. For each concept $C_i$, the value
block induces the DL axiom \[C_i \sqsubseteq (V \in P)\] stating that
each instance of $C_i$ has a value $V$ for property $P$.  The value
restrictions stated by value blocks are often used for defining
so-called \emph{value partitions} \cite{co-ode}.

\paragraph{Inverse Block.} Inverse blocks state that two object
properties are inverses of each other. That is, for inverse properties
$P_1$ and $P_2$ and concept instances $O_1$ and $O_2$, if $P_1(O_1) =
O_2$, then $P_2(O_2) = O_1$.  An inverse block has the form
\begin{itemize}
\item[]
  \begin{tabular}{|l|l|l|}\hline \texttt{inverse} & $P_1$ & $P_2$
\\ \hline
  \end{tabular}
\end{itemize}
where $P_1$ and $P_2$ are object properties. 

\paragraph{Minimum Block.} Minimum blocks state the minimum
number of properties $P$ an instance of a concept may have.
Minimum blocks have the form
\begin{itemize}
\item[]
  \begin{tabular}{|l|l|l|l|l|l|l|}\hline \texttt{minimum} & $P$ & $N$ & 
    $C_1$ & $C_2$ & $\dots$ & $C_m$
    \\ \hline
  \end{tabular}
\end{itemize}
where $N$ is the minimum number of properties $P$ that instances of
concept $C_1$ may have to instances of concept $C_2$, $C_2$ to $C_3$,
and so on. A cardinality block induces the DL axiom \[C_i \sqsubseteq
(\le N P.C_{i+1})\] stating that each instance of $C_i$ must be related to
at least $N$ unique instances of $C_{i+1}$ via $P$. For example, the blocks
\begin{quote}
\texttt{minimum} \texttt{hasPart} 1 \texttt{Body} \texttt{Head} \\
\texttt{minimum} \texttt{hasPart} 2 \texttt{Head} \texttt{Eye}
\end{quote}
states that a body has at least one head and at least two eyes.

\paragraph{Maximum Block.} Maximum blocks state the maximum
number of properties $P$ an instance of a concept may have.
Maximum blocks have the form
\begin{itemize}
\item[]
  \begin{tabular}{|l|l|l|l|l|l|l|}\hline \texttt{maximum} & $P$ & $N$ & 
    $C_1$ & $C_2$ & $\dots$ & $C_m$
    \\ \hline
  \end{tabular}
\end{itemize}
where $N$ is the maximum number of properties $P$ that instances of
concept $C_1$ may have to instances of concept $C_2$, $C_2$ to $C_3$,
and so on. A cardinality block induces the DL axiom \[C_i \sqsubseteq
(\ge N P.C_{i+1})\] stating that each instance of $C_i$ may be related to
at most $N$ unique instances of $C_{i+1}$ via $P$. For example, the blocks
\begin{quote}
\texttt{maximum} \texttt{hasPart} 1 \texttt{Body} \texttt{Head} \\
\texttt{maximum} \texttt{hasPart} 2 \texttt{Head} \texttt{Eye}
\end{quote}
states that a body has at least one head and at least two eyes.


\paragraph{Sufficient Block.} Sufficient blocks state that any
instance having a property $P$ to an instance of a concept $C_2$ is a
sufficient condition for being an instance of a concept $C_1$. A
sufficient block has the form
\begin{itemize}
\item[]
  \begin{tabular}{|l|l|l|l|}\hline \texttt{sufficient} & $C_1$ & $P$ & $C_2$
    \\ \hline
  \end{tabular}
\end{itemize}
where $C_1$ is the target concept (i.e., denoting the concept
definition), $P$ is the sufficient property, and $C_2$ is the
sufficient concept. A sufficient block induces the DL axiom \[C_1
\equiv \exists P.C_2\] Sufficient blocks provide a mechansism to
construct simple class definitions (i.e., classes defined precisely by
other classes), primarily for use with value partitions. [NOTE: these
should be anded together?]

\paragraph{Description Block.} Description blocks assign plain-text
definitions to concepts and properties. A description block has the
form
\begin{itemize}
\item[]
  \begin{tabular}{|l|l|l|}\hline \texttt{description} & $T$ & $S$
\\ \hline
  \end{tabular}
\end{itemize}
where $T$ is either a property or a concept and $S$ is a description
string.

\paragraph{Note Block.} Note blocks add comments to the current
ontology, and are ignored by \owlifier.  A note block has the form
\begin{itemize}
\item[]
  \begin{tabular}{|l|l|l|}\hline \texttt{note} & $S$
\\ \hline
  \end{tabular}
\end{itemize}
where $S$ is a comment string.

*** Say something about relaxing block syntax ... to make it easier to
specify ontologies. Also, allow blocks to be given in any order.



%\bibliographystyle{elsarticle-num}
\bibliographystyle{abbrv}
\bibliography{main}


\end{document}

